#pragma config(Sensor, in1,    mobilePot,      sensorPotentiometer)
#pragma config(Sensor, in2,    liftLeftPot,    sensorPotentiometer)
#pragma config(Sensor, in3,    armPot,         sensorPotentiometer)
#pragma config(Sensor, in4,    liftRightPot,   sensorPotentiometer)
#pragma config(Sensor, dgtl1,  rightDriveEnc,  sensorQuadEncoder)
#pragma config(Sensor, dgtl3,  leftDriveEnc,   sensorQuadEncoder)
#pragma config(Sensor, dgtl5,  rollerEnc,      sensorQuadEncoder)
#pragma config(Sensor, dgtl7,  MOSI,           sensorDigitalOut)
#pragma config(Sensor, dgtl8,  SCLK,           sensorDigitalOut)
#pragma config(Motor,  port1,           swingingArm,   tmotorVex393_HBridge, openLoop)
#pragma config(Motor,  port2,           driveBL,       tmotorVex393HighSpeed_MC29, openLoop, reversed)
#pragma config(Motor,  port3,           driveBR,       tmotorVex393HighSpeed_MC29, openLoop, encoderPort, None)
#pragma config(Motor,  port4,           driveFL,       tmotorVex393HighSpeed_MC29, openLoop, reversed)
#pragma config(Motor,  port5,           driveFR,       tmotorVex393HighSpeed_MC29, openLoop)
#pragma config(Motor,  port6,           mobileGoal,    tmotorVex393HighSpeed_MC29, openLoop)
#pragma config(Motor,  port7,           roller,        tmotorVex393HighSpeed_MC29, openLoop, reversed)
#pragma config(Motor,  port8,           liftL,         tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port9,           liftR,         tmotorVex393_MC29, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

// Declare VEX as the robot platform

#pragma platform(VEX)

// Competition Control and Duration Settings
#pragma competitionControl(Competition)
#pragma autonomousDuration(20)
#pragma userControlDuration(120)

#include "Vex_Competition_Includes.c"   //Main competition background code...do not modify!

// **** Important programmer notes ****
//
// When upgrading ROBOTC the Robot Platform Settings are lost and must be reset
// otherwise compiler error will result. Ensure the following are set:
// 		Robot -> Platform Type -> VEX 2.0 Cortex
// 		Robot -> Platform Type -> VEX Robotics -> VEX 2.0 Cortex
// 		Robot -> Platform Type -> Natural Language (PLTW)
//
//
// Note: Sometime when upgrading FW on the controller and/or joystick, the FW for the
//       VEXNet Keys must also be upgraded. The symptom of needing this upgrade is a
//       failure of the controller and joystick to communicate with each other.
//
//
// Note: When RobotC refuses to download code to the robot, first try manually selecting the
//       COM port. If that doesn't work then it may be necessary reload the firmware. First
//       update the main FW and then the RobotC FW. Don't forget to rename robot afterwards.
//
//
// Variable info:
//
//		int, short, word - 2 bytes
//		long - 4 bytes
//		SensorValue() returns 2 byte value

// Control debugger windows by defining these pragmas
#pragma DebuggerWindows("debugStream")

#include "Team8800Lib.c"		// Utility routines to simplify programming
#include "Team8800Led.c"		// Routines to control the LED strip
#include "MultiTask.c"  // Motor slew control

// Delcarations

// Initialize
void initialize();
void selectTeamAlliance();

// Controller Input
//void processController();

// Autonomous
//void autonomousRoutines();

// Robot Action

//Functions
void moveLiftDown();

void moveArmBack();
void moveArmBackLvl1and2();
void moveArmForward();
void moveLiftUp4(int height);
void moveLiftUp5(int height);
void rollerIntake(int speed);
void rollerOutake(int speed);

void liftPIControl (float position);
void liftPIControlLvl6AndUp (float position);

void checkPositions();

//Auto Functions
void autoLiftControl (int height);
void drive(int left, int right);
void driveForward(int speed, int distance);
void driveBackward(int speed, int distance);
void clearDriveEnc();
void moveMobileGoalOut();
void moveMobileGoalIn();

// Constants and global vars
const byte MIN_JOYSTICK_THRESHOLD = 30;

const byte RED_ALLIANCE = 1;
const byte BLUE_ALLIANCE = 2;
byte allianceColor = BLUE_ALLIANCE;

const byte LEFT = 1;
const byte RIGHT = 2;
byte allianceSide = RIGHT;

const byte AUTONOMOUS_MODE_CUBE = 1;
const byte AUTONOMOUS_MODE_CUBE_BACK_STAR = 2;
const byte AUTONOMOUS_MODE_FENCE = 3;
const byte AUTONOMOUS_MODE_SKILLS = 4;
const byte AUTONOMOUS_MODE_STACK_DRIVE = 5;
const byte AUTONOMOUS_MODE_STACK_PIPE = 6;
const byte AUTONOMOUS_MODE_STACK_BACK = 7;
const byte AUTONOMOUS_MODE_DRIVE_BLOCK = 8;
byte autonomousMode = AUTONOMOUS_MODE_CUBE;

const byte PRESET_LEVEL_ONE = 1;
const byte PRESET_LEVEL_TWO = 2;
const byte PRESET_LEVEL_THREE = 3;
const byte PRESET_LEVEL_FOUR = 4;
const byte PRESET_LEVEL_FIVE = 5;
const byte PRESET_LEVEL_SIX = 6;
const byte PRESET_LEVEL_SEVEN = 7;
const byte PRESET_LEVEL_EIGHT = 8;
const byte PRESET_LEVEL_NINE = 9;
const byte PRESET_LEVEL_TEN = 10;
const byte PRESET_LEVEL_ELEVEN = 11;
const byte PRESET_LEVEL_TWELVE = 12;
const byte PRESET_LEVEL_THIRTEEN = 13;
const byte PRESET_LEVEL_FOURTEEN = 14;
const byte PRESET_LEVEL_FIFTEEN = 15;
byte presetLevel = PRESET_LEVEL_ONE;

const byte DRIVE_SLOW_FORWARD = 60;
const byte DRIVE_SLOW_REVERSE = -60;

unsigned long autonomousStartTime;

const byte AUTONOMOUS = 1;
const byte USER_CONTROL = 2;
byte robotMode = 1;

bool presetLevelActive = false;
bool presetLevelJustActive = false;

bool boingyPointOn = true;
bool armBack = false;
bool armFront = true;

bool armIsBack;
bool armIsBackLvl1and2;
bool armIsForward;
bool liftLeftIsPosition4;
bool liftRightIsPosition4 = false;
bool liftIsPosition4Again = false;
bool liftIsPosition5;
bool liftIsPosition6;
bool liftIsDown = false;

bool rollerIntaking = false;
bool rollerOutaking = false;

bool btnSixUPressed = false;
bool btnSixDPressed = false;

bool presetLevelScrollUp = false;
bool presetLevelScrollDown = false;

int level4Height = 85;
int level5Height = 115;
int level6Height = 260;
int level7Height = 370;
int level8Height = 470;
int level9Height = 570;
int level10Height = 800;
int level11Height = 100;
int level12Height = 120;
int level13Height = 120;
int level14Height = 120;
int level15Height = 120;

int liftError = 20;
int armError = 20;

float liftLeftError;
float liftRightError;
float leftErrorT;
float rightErrorT;

float leftkp = 0.3;
float leftki = 0.0000009;

float rightkp = 0.3;
float rightki = 0.000001;


float leftCurrent;
float rightCurrent;

float integralAcitveZone = 500;

float leftProportion;
float leftIntegral;
float rightProportion;
float rightIntegral;

int armPotPosition = 2900;
int getToArmSpeed = 35;

int rollerRotationsOut = 0;

int savedValueHeight;
int savedValueHeight4;

int rollerSpeed;

void pre_auton()
{
	bStopTasksBetweenModes = true;

	clearDebugStream();
	writeDebugStreamLine("Pre-Autonomous...");

	// Select alliance using LCD and indicate selection with LEDs
	selectTeamAlliance();
}

task autonomousRoutines()
{
	switch (autonomousMode) {
	case AUTONOMOUS_MODE_CUBE:
		if (allianceSide == LEFT && allianceColor == BLUE_ALLIANCE) {
			//Move lift up
			autoLiftControl(500);
			writeDebugStreamLine("Lift at position %d", liftLeftIsPosition4);
			motor[liftL] = 55;
			motor[liftR] = 55;

			//Move swinging arm to stop
			while (/*SensorValue[armPot] > 2900 ||*/ SensorValue[mobilePot] > 20) {
				if (SensorValue[armPot] > 2900) {
					motor[swingingArm] = 127;
					writeDebugStreamLine ("armPot, %d", SensorValue[armPot]);
					} else {
					motor[swingingArm] = 0;
				}
				if (SensorValue[mobilePot] > 20) {
					motor[mobileGoal] = 127;
					} else {
					motor[mobileGoal] = 0;
				}
			}
			writeDebugStreamLine("Check 1");

			//Make sure arm and mobil goal are set to zero
			motor[mobileGoal] = 0;
			motor[swingingArm] = 0;

			//Clear drive encoders and set arm to passive
			clearDriveEnc();
			motor[swingingArm] = -10;

			//Start driving
			driveForward(60, 1300);
			waitInMilliseconds(250);


			waitInMilliseconds(350);
			//Move mobil goal collector in
			while (SensorValue[mobilePot] < 3900) {
				motor[mobileGoal] = -127;
			}
			motor[mobileGoal] = 0;

			//Drive back after slight delay and clearing encoders
			clearDriveEnc();
			waitInMilliseconds(250);
			driveBackward(-100, -1000);

			//Jerk at the end of backing up
			drive(90, 90);
			waitInMilliseconds(100);
			drive(0, 0);

			//Move lift down
			waitInMilliseconds(100);
			moveLiftDown();
			motor[liftL] = -30;
			motor[liftR] = -30;

			//Release Cone
			waitInMilliseconds(1800);
			motor[roller] = -60;
			waitInMilliseconds(750);
			motor[roller] = 0;

			//Drive backwards turinging left
			drive(-100, -18);
			waitInMilliseconds(1300);
			drive(0, 0);
			waitInMilliseconds(350);
			drive(-50, 50);
			waitInMilliseconds(480);
			drive(0, 0);

			waitInMilliseconds(150);

			//Raise lift
			autoLiftControl(500);
			motor[liftL] = 30;
			motor[liftR] = 30;

			//Drive forward and raise mobile goal
			while (SensorValue[mobilePot] > 2000) {
				drive(100, 100);
				motor[mobileGoal] = 127;
			}
			drive(0, 0);
			motor[mobileGoal] = 0;

			drive(-100, -100);
			waitInMilliseconds(750);
			drive(0, 0);

			writeDebugStreamLine ("Finished");

		} else if (allianceSide == RIGHT && allianceColor == BLUE_ALLIANCE) {
			//Move lift up
			autoLiftControl(500);
			writeDebugStreamLine("Lift at position %d", liftLeftIsPosition4);
			motor[liftL] = 25;
			motor[liftR] = 25;

			//Move swinging arm to stop
			while (/*SensorValue[armPot] > 2900 ||*/ SensorValue[mobilePot] > 20) {
				if (SensorValue[armPot] > 2900) {
					motor[swingingArm] = 127;
					writeDebugStreamLine ("armPot, %d", SensorValue[armPot]);
					} else {
					motor[swingingArm] = 0;
				}
				if (SensorValue[mobilePot] > 20) {
					motor[mobileGoal] = 127;
					} else {
					motor[mobileGoal] = 0;
				}
			}
			writeDebugStreamLine("Check 1");

			//Make sure arm and mobil goal are set to zero
			motor[mobileGoal] = 0;
			motor[swingingArm] = 0;

			//Clear drive encoders and set arm to passive
			clearDriveEnc();
			motor[swingingArm] = -10;

			//Start driving
			driveForward(100, 1200);

			waitInMilliseconds(400);
			//Move mobil goal collector in
			while (SensorValue[mobilePot] < 3900) {
				motor[mobileGoal] = -100;
			}
			motor[mobileGoal] = 0;

			//Drive back after slight delay and clearing encoders
			clearDriveEnc();
			waitInMilliseconds(250);
			driveBackward(-100, -1200);

			//Jerk at the end of backing up
			drive(90, 90);
			waitInMilliseconds(100);
			drive(0, 0);

			//Move lift down
			waitInMilliseconds(100);
			moveLiftDown();
			motor[liftL] = -30;
			motor[liftR] = -30;

			//Release Cone
			waitInMilliseconds(1500);
			motor[roller] = -60;
			waitInMilliseconds(750);
			motor[roller] = 0;

			//Drive backwards turinging right
			drive(-18, -100);
			waitInMilliseconds(800);
			drive(0, 0);
			waitInMilliseconds(600);
			drive(50, -50);
			waitInMilliseconds(800);
			drive(0, 0);

			waitInMilliseconds(150);

			//Raise lift
			autoLiftControl(700);
			motor[liftL] = 30;
			motor[liftR] = 30;

			//Drive forward and raise mobile goal
			//while (SensorValue[mobilePot] > 2000) {
			drive(100, 100);
			motor[mobileGoal] = 127;
			writeDebugStreamLine("Mobile goal Pot %d", mobilePot);
			datalogAddValueWithTimeStamp(0, SensorValue[mobilePot]);
			waitInMilliseconds(1250);
			//}
			drive(0, 0);
			motor[mobileGoal] = 0;

			drive(-100, -100);
			waitInMilliseconds(750);
			drive(0, 0);

			writeDebugStreamLine ("Finished");

		} else if (allianceSide == LEFT && allianceColor == RED_ALLIANCE) {
			//Move lift up
			autoLiftControl(500);
			writeDebugStreamLine("Lift at position %d", liftLeftIsPosition4);
			motor[liftL] = 25;
			motor[liftR] = 25;

			//Move swinging arm to stop
			while (/*SensorValue[armPot] > 2900 ||*/ SensorValue[mobilePot] > 20) {
				if (SensorValue[armPot] > 2900) {
					motor[swingingArm] = 127;
					writeDebugStreamLine ("armPot, %d", SensorValue[armPot]);
					} else {
					motor[swingingArm] = 0;
				}
				if (SensorValue[mobilePot] > 20) {
					motor[mobileGoal] = 127;
					} else {
					motor[mobileGoal] = 0;
				}
			}
			writeDebugStreamLine("Check 1");

			//Make sure arm and mobil goal are set to zero
			motor[mobileGoal] = 0;
			motor[swingingArm] = 0;

			//Clear drive encoders and set arm to passive
			clearDriveEnc();
			motor[swingingArm] = -10;

			//Start driving
			driveForward(100, 1200);

			waitInMilliseconds(250);
			//Move mobil goal collector in
			while (SensorValue[mobilePot] < 3800) {
				motor[mobileGoal] = -100;
			}
			motor[mobileGoal] = 0;

			//Drive back after slight delay and clearing encoders
			clearDriveEnc();
			waitInMilliseconds(250);
			driveBackward(-100, -1000);

			//Jerk at the end of backing up
			drive(90, 90);
			waitInMilliseconds(100);
			drive(0, 0);

			//Move lift down
			waitInMilliseconds(100);
			moveLiftDown();
			motor[liftL] = -35;
			motor[liftR] = -35;

			//Release Cone
			waitInMilliseconds(1500);
			motor[roller] = -60;
			waitInMilliseconds(750);
			motor[roller] = 0;

			//Drive backwards turinging right
			drive(-100, -18);
			waitInMilliseconds(1300);
			drive(0, 0);
			waitInMilliseconds(200);
			drive(-50, 50);
			waitInMilliseconds(450);
			drive(0, 0);

			waitInMilliseconds(150);

			//Raise lift
			autoLiftControl(500);
			motor[liftL] = 30;
			motor[liftR] = 30;

			//Drive forward and raise mobile goal
			while (SensorValue[mobilePot] > 2000) {
				drive(100, 100);
				motor[mobileGoal] = 127;
			}
			drive(0, 0);
			motor[mobileGoal] = 0;

			drive(-100, -100);
			waitInMilliseconds(750);
			drive(0, 0);

			writeDebugStreamLine ("Finished");

		}else if (allianceSide == RIGHT && allianceColor == RED_ALLIANCE) {
			//Move lift up
			autoLiftControl(500);
			writeDebugStreamLine("Lift at position %d", liftLeftIsPosition4);
			motor[liftL] = 55;
			motor[liftR] = 55;

			//Move swinging arm to stop
			while (/*SensorValue[armPot] > 2900 ||*/ SensorValue[mobilePot] > 20) {
				if (SensorValue[armPot] > 2900) {
					motor[swingingArm] = 127;
					writeDebugStreamLine ("armPot, %d", SensorValue[armPot]);
					} else {
					motor[swingingArm] = 0;
				}
				if (SensorValue[mobilePot] > 20) {
					motor[mobileGoal] = 127;
					} else {
					motor[mobileGoal] = 0;
				}
			}
			writeDebugStreamLine("Check 1");

			//Make sure arm and mobil goal are set to zero
			motor[mobileGoal] = 0;
			motor[swingingArm] = 0;

			//Clear drive encoders and set arm to passive
			clearDriveEnc();
			motor[swingingArm] = -10;

			//Start driving
			driveForward(60, 1300);
			waitInMilliseconds(250);


			waitInMilliseconds(350);
			//Move mobil goal collector in
			while (SensorValue[mobilePot] < 3900) {
				motor[mobileGoal] = -127;
			}
			motor[mobileGoal] = 0;

			//Drive back after slight delay and clearing encoders
			clearDriveEnc();
			waitInMilliseconds(250);
			driveBackward(-100, -1000);

			//Jerk at the end of backing up
			drive(90, 90);
			waitInMilliseconds(100);
			drive(0, 0);

			//Move lift down
			waitInMilliseconds(100);
			moveLiftDown();
			motor[liftL] = -30;
			motor[liftR] = -30;

			//Release Cone
			waitInMilliseconds(1800);
			motor[roller] = -60;
			waitInMilliseconds(750);
			motor[roller] = 0;

			//Drive backwards turinging left
			drive(-18, -100);
			waitInMilliseconds(1300);
			drive(0, 0);
			waitInMilliseconds(200);
			drive(50, -50);
			waitInMilliseconds(450);
			drive(0, 0);

			waitInMilliseconds(150);

			//Raise lift
			autoLiftControl(700);
			motor[liftL] = 30;
			motor[liftR] = 30;

			//Drive forward and raise mobile goal
			while (SensorValue[mobilePot] > 2000) {
				drive(100, 100);
				motor[mobileGoal] = 127;
			}
			drive(0, 0);
			motor[mobileGoal] = 0;

			drive(-100, -100);
			waitInMilliseconds(750);
			drive(0, 0);

			writeDebugStreamLine ("Finished");
		}

		if (allianceColor == BLUE_ALLIANCE) {
			theaterChaseTask(0, 0, 127, 50, 15000);
			} else {
			theaterChaseTask(127, 0, 0, 50, 15000);
		}
		break;

	case AUTONOMOUS_MODE_CUBE_BACK_STAR:

		if (allianceColor == BLUE_ALLIANCE) {
			theaterChaseTask(0, 0, 127, 50, 15000);
			} else {
			theaterChaseTask(127, 0, 0, 50, 15000);
		}
		break;

	case AUTONOMOUS_MODE_FENCE:

		if (allianceColor == BLUE_ALLIANCE) {
			theaterChaseTask(0, 0, 127, 50, 15000);
			} else {
			theaterChaseTask(127, 0, 0, 50, 15000);
		}

		break;

	case AUTONOMOUS_MODE_SKILLS:


		break;

	case AUTONOMOUS_MODE_STACK_DRIVE:

		break;

	case AUTONOMOUS_MODE_STACK_PIPE:

		break;

	case AUTONOMOUS_MODE_STACK_BACK:

		break;

	case AUTONOMOUS_MODE_DRIVE_BLOCK:

		break;
	}
}

task autonomous()
{
	robotMode = AUTONOMOUS;

	autonomousStartTime = nSysTime;
	writeDebugStreamLine("Starting Autonomous...");

	if (false) AutonomousCodePlaceholderForTesting();  // complains if I remove this

	initialize();
	startTask(autonomousRoutines);
}

task ProcessController()
{
	while(true) {

		/*
		Main Controller:
		joysticks = drive

		Partner Contorller:
		right joystick = catapult
		*/

		// --- Joysticks to control robot driving (main controller only)

		static byte rightJoystickY, leftJoystickY, prevRightJoystickY = 0, prevLeftJoystickY = 0;

		rightJoystickY = readRightJoystickYAxis();
		leftJoystickY = readLeftJoystickYAxis();

		static bool rightDriveMoving = false;
		if (abs(rightJoystickY) > MIN_JOYSTICK_THRESHOLD) {
			//if (prevRightJoystickY != rightJoystickY) {
			rightDriveMoving = true;
			motorReq[driveFR] = rightJoystickY;
			motorReq[driveBR] = rightJoystickY;
			writeDebugStreamLine("Right: %d%%", rightJoystickY);
			//}
			} else {
			//if (rightDriveMoving) {
			rightDriveMoving = false;
			motorReq[driveFR] = 0;
			motorReq[driveBR] = 0;
			//}
		}

		static bool leftDriveMoving = false;
		if (abs(leftJoystickY) > MIN_JOYSTICK_THRESHOLD) {
			//if (prevLeftJoystickY != leftJoystickY) {
			leftDriveMoving = true;
			motorReq[driveFL] = leftJoystickY;
			motorReq[driveBL] = leftJoystickY;
			writeDebugStreamLine("Left: %d%%", leftJoystickY);
			//}
			} else {
			//if (leftDriveMoving) {
			leftDriveMoving = false;
			motorReq[driveFL] = 0;
			motorReq[driveBL] = 0;
			//}
		}

		//Boingy Point Activation
		//Off
		if (isButtonPressed(Btn7U)) {
			boingyPointOn = false;
		} else if (isButtonPressed(Btn7D)) {
			boingyPointOn = true;
		}

		//Manual 4-bar control
		prevRightJoystickY = rightJoystickY;
		prevLeftJoystickY = leftJoystickY;

		if (!boingyPointOn) {
			if (isButtonPressed(Btn5U)) {
				turnMotor(liftL, 127);
				turnMotor(liftR, 127);
				} else if (isButtonPressed(Btn5D)) {
				turnMotor(liftL, -127);
				turnMotor(liftR, -127);
				} else {
				turnMotor(liftL, 0);
				turnMotor(liftR, 0);
			}
			} else if (boingyPointOn) {
			if (!presetLevelActive) {
				/*
				if (SensorValue[liftLeftPot] < 50){
				motor[liftL] = 100;
				} else if (SensorValue[liftLeftPot] >= 50 && SensorValue[liftLeftPot] < 105) {
				motor[liftL] = 30;
				} else if (SensorValue[liftLeftPot] >= 105 && SensorValue[liftLeftPot] < 140 - (liftError/2)) {
				motor[liftL] = 10;
				} else if (SensorValue[liftLeftPot] >= 140 + (liftError/2) && SensorValue[liftLeftPot] < 200) {
				motor[liftL] = -10;
				} else if (SensorValue[liftLeftPot] >= 200 && SensorValue[liftLeftPot] < 500) {
				motor[liftL] = -50;
				} else if (SensorValue[liftLeftPot] >= 500 && SensorValue[liftLeftPot] < 1200) {
				motor[liftL] = -100;
				} else if (SensorValue[liftLeftPot] <= 140 + (liftError/2) && SensorValue[liftLeftPot] > 140 - (liftError/2)) {
				motor[liftL] = 0;
				}

				if (SensorValue[liftRightPot] < 50){
				motor[liftR] = 100;
				} else if (SensorValue[liftRightPot] >= 50 && SensorValue[liftRightPot] < 105) {
				motor[liftR] = 30;
				} else if (SensorValue[liftRightPot] >= 105 && SensorValue[liftRightPot] < 140 - (liftError/2)) {
				motor[liftR] = 10;
				} else if (SensorValue[liftRightPot] >= 140 + (liftError/2) && SensorValue[liftRightPot] < 200) {
				motor[liftR] = -10;
				} else if (SensorValue[liftRightPot] >= 200 && SensorValue[liftRightPot] < 500) {
				motor[liftL] = -50;
				} else if (SensorValue[liftRightPot] >= 500 && SensorValue[liftRightPot] < 1200) {
				motor[liftR] = -100;
				} else if (SensorValue[liftRightPot] <= 140 + (liftError/2) && SensorValue[liftRightPot] > 140 - (liftError/2)) {
				motor[liftR] = 0;
				}*/

				//Normal Hieght
				liftPIControl(140);

				//Button For Collect
				if (isButtonPressed(Btn6D)) {
					if (SensorValue[liftRightPot] > 20) {
						motor[liftL] = -80;
						motor[liftR] = -80;
						} else {
						motor[liftL] = -5;
						motor[liftR] = -5;
					}
					motor[roller] = 100;
				} else {
					motor[roller] = 25;
				}
			}

			if (presetLevelJustActive && !armIsForward) {
				rollerIntake(-60);

				if (presetLevel == 1) {
					motor[liftL] = -40;
					motor[liftR] = -40;
					} else if (presetLevel == 2) {
					motor[liftL] = -40;
					motor[liftR] = -40;
					} else if (presetLevel == 3) {
					motor[liftL] = 15;
					motor[liftR] = 15;
					} else if (presetLevel == 4) {
					motor[liftL] = 30;
					motor[liftR] = 30;
					} else if (presetLevel == 5) {
					motor[liftL] = 30;
					motor[liftR] = 30;
					} else if (presetLevel == 6) {
					motor[liftL] = 30;
					motor[liftR] = 30;
					} else if (presetLevel == 7) {
					motor[liftL] = 35;
					motor[liftR] = 35;
					} else if (presetLevel == 8) {
					motor[liftL] = 35;
					motor[liftR] = 35;
					} else if (presetLevel == 9) {
					motor[liftL] = 40;
					motor[liftR] = 40;
					} else if (presetLevel == 10) {
					motor[liftL] = 40;
					motor[liftR] = 40;
					} else if (presetLevel == 11) {
					motor[liftL] = 45;
					motor[liftR] = 45;
					} else if (presetLevel == 12) {
					motor[liftL] = 45;
					motor[liftR] = 45;
					} else if (presetLevel == 13) {
					motor[liftL] = 50;
					motor[liftR] = 50;
					} else if (presetLevel == 14) {
					motor[liftL] = 50;
					motor[liftR] = 50;
					} else if (presetLevel == 15) {
					motor[liftL] = 55;
					motor[liftR] = 55;
				}

				if (SensorValue[rollerEnc] > 500) {
					moveArmForward();
				}
				} else if (armIsForward) {
				presetLevelJustActive = false;
			}

			checkPositions();

			//Activate Level Button
			if (isButtonPressed(Btn8UXmtr2)) {
				presetLevelActive = true;
				} else if (isButtonPressed(Btn8DXmtr2)) {
				presetLevelActive = false;
				presetLevelJustActive = true;
			}

			if (vexRT[Btn6UXmtr2] && !btnSixUPressed) {
				btnSixUPressed = true;
				} else if (!vexRT[Btn6UXmtr2] && btnSixUPressed) {
				presetLevel += 1;
				btnSixUPressed = false;
			}

			if (vexRT[Btn6DXmtr2] && !btnSixDPressed) {
				btnSixDPressed = true;
				} else if (!vexRT[Btn6DXmtr2] && btnSixDPressed) {
				presetLevel -= 1;
				btnSixDPressed = false;
			}

			if (vexRT[Btn8RXmtr2]) {
				presetLevel = 1;
				presetLevelJustActive = true;
				presetLevelActive = false;
			}

			//Automatic Level Stuff
			if (presetLevelActive) {
				switch (presetLevel) {
				case PRESET_LEVEL_ONE:					// preset level one ////////////////////////////////////////////////
					//if (!armIsBackLvl1and2 && SensorValue[rollerEnc] > -500) {
					rollerIntake(25);
					//}

					moveLiftDown();
					//if (/*!armIsBackLvl1and2 && */ !liftIsDown/* && SensorValue[rollerEnc] > -500*/) {
					//moveArmBackLvl1and2();

					//rollerIntake(25);
					//SensorValue[rollerEnc] = 0;
					//}

					SensorValue[rollerEnc] = 0;

					moveArmBackLvl1and2();

					/*if (rollerRotationsOut < -500) {
					presetLevelActive = false;
					presetLevelJustActive = true;
					}*/

					/*if (armIsForward) {
					presetLevelActive = false;
					}*/
					break;

				case PRESET_LEVEL_TWO:					// preset level two ////////////////////////////////////////////////
					rollerIntake(25);

					moveLiftDown();
					//if (/*!armIsBackLvl1and2 && */ !liftIsDown/* && SensorValue[rollerEnc] > -500*/) {
					//moveArmBackLvl1and2();

					//rollerIntake(25);
					//SensorValue[rollerEnc] = 0;
					//}

					SensorValue[rollerEnc] = 0;

					moveArmBackLvl1and2();

					/*if (SensorValue[rollerEnc] < -500) {
					presetLevelActive = false;
					presetLevelJustActive = true;
					}*/

					/*if (armIsForward) {
					presetLevelActive = false;
					}*/
					/*if (!armIsBackLvl1and2 && SensorValue[rollerEnc] > -500) {
					moveArmBackLvl1and2();
					motor[roller] = 25;
					writeDebugStreamLine("working");
					}

					if (armIsBackLvl1and2 && SensorValue[rollerEnc] > -500 && !liftIsDown) {
					moveArmBackLvl1and2();
					moveLiftDown();
					SensorValue[rollerEnc] = 0;
					}

					if (SensorValue[rollerEnc] > -500 && SensorValue[rollerEnc] < 20 && liftIsDown) {
					moveArmBackLvl1and2();
					motor[roller] = -55;
					}

					if (SensorValue[rollerEnc] < -500) {
					moveArmForward();
					}

					if (armIsForward) {
					presetLevelActive = false;
					presetLevelJustActive = true;
					}*/
					break;

				case PRESET_LEVEL_THREE:					// preset level three ////////////////////////////////////////////////
					rollerIntake(25);

					if (/*!armIsBackLvl1and2 && */ !liftIsDown/* && SensorValue[rollerEnc] > -500*/) {
						//moveArmBackLvl1and2();
						moveLiftDown();
						//rollerIntake(25);
						//SensorValue[rollerEnc] = 0;
					}

					SensorValue[rollerEnc] = 0;

					moveArmBackLvl1and2();

					/*if (SensorValue[rollerEnc] < -500) {
					presetLevelActive = false;
					presetLevelJustActive = true;
					}*/
					/*if (!armIsBack && SensorValue[rollerEnc] > -500) {
					moveArmBack();
					motor[roller] = 25;
					}

					if (armIsBack && SensorValue[rollerEnc] > -500 && !liftIsDown) {
					moveArmBack();
					moveLiftDown();
					SensorValue[rollerEnc] = 0;
					}

					if (SensorValue[rollerEnc] > -500 && SensorValue[rollerEnc] < 20 && liftIsDown) {
					moveArmBack();
					motor[roller] = -55;
					}

					if (SensorValue[rollerEnc] < -500) {
					moveArmForward();
					}

					if (armIsForward) {
					presetLevelActive = false;
					}*/
					break;

				case PRESET_LEVEL_FOUR:						// preset level four ////////////////////////////////////////////////
					rollerIntake(25);

					if (!liftRightIsPosition4) {
						liftPIControl(level4Height);
						//rollerIntake(25);
					}

					SensorValue[rollerEnc] = 0;

					moveArmBackLvl1and2();
					/*if (liftRightIsPosition4 && armIsBackLvl1and2) {
					moveArmBackLvl1and2();
					rollerIntake(-60);
					motor[liftL] = 20;
					motor[liftR] = 20;
					} else {
					moveArmBackLvl1and2();
					}*/

					/*if (SensorValue[rollerEnc] < -500) {
					presetLevelActive = false;
					presetLevelJustActive = true;
					}*/
					break;


				case PRESET_LEVEL_FIVE:
					rollerIntake(25);

					if (!liftRightIsPosition4) {
						liftPIControl(level5Height);
						//rollerIntake(25);
					}

					SensorValue[rollerEnc] = 0;

					moveArmBackLvl1and2();

					/*if (SensorValue[rollerEnc] < -500) {
					presetLevelActive = false;
					presetLevelJustActive = true;
					}*/
					break;

				case PRESET_LEVEL_SIX:
					rollerIntake(25);

					if (!liftRightIsPosition4) {
						liftPIControlLvl6AndUp(level6Height);
						//rollerIntake(25);
					}

					SensorValue[rollerEnc] = 0;

					moveArmBackLvl1and2();

					/*if (SensorValue[rollerEnc] < -500) {
					presetLevelActive = false;
					presetLevelJustActive = true;
					}*/
					break;

				case PRESET_LEVEL_SEVEN:
					rollerIntake(25);

					if (!liftRightIsPosition4) {
						liftPIControlLvl6AndUp(level7Height);
					}

					SensorValue[rollerEnc] = 0;

					moveArmBackLvl1and2();
					break;

				case PRESET_LEVEL_EIGHT:
					rollerIntake(25);

					if (!liftRightIsPosition4) {
						liftPIControlLvl6AndUp(level8Height);
					}

					SensorValue[rollerEnc] = 0;

					moveArmBackLvl1and2();
					break;

				case PRESET_LEVEL_NINE:
					rollerIntake(25);

					if (!liftRightIsPosition4) {
						liftPIControlLvl6AndUp(level9Height);
					}

					SensorValue[rollerEnc] = 0;

					moveArmBackLvl1and2();
					break;

				case PRESET_LEVEL_TEN:
					rollerIntake(25);

					if (!liftRightIsPosition4) {
						liftPIControlLvl6AndUp(level10Height);
					}

					SensorValue[rollerEnc] = 0;

					moveArmBackLvl1and2();
					break;

				case PRESET_LEVEL_ELEVEN:
					rollerIntake(25);

					if (!liftRightIsPosition4) {
						liftPIControlLvl6AndUp(level11Height);
					}

					SensorValue[rollerEnc] = 0;

					moveArmBackLvl1and2();
					break;

				case PRESET_LEVEL_TWELVE:
					rollerIntake(25);

					if (!liftRightIsPosition4) {
						liftPIControlLvl6AndUp(level12Height);
					}

					SensorValue[rollerEnc] = 0;

					moveArmBackLvl1and2();
					break;

				case PRESET_LEVEL_THIRTEEN:
					rollerIntake(25);

					if (!liftRightIsPosition4) {
						liftPIControlLvl6AndUp(level13Height);
					}

					SensorValue[rollerEnc] = 0;

					moveArmBackLvl1and2();
					break;

				case PRESET_LEVEL_FOURTEEN:
					rollerIntake(25);

					if (!liftRightIsPosition4) {
						liftPIControlLvl6AndUp(level14Height);
					}

					SensorValue[rollerEnc] = 0;

					moveArmBackLvl1and2();
					break;
				case PRESET_LEVEL_FIFTEEN:
					rollerIntake(25);

					if (!liftRightIsPosition4) {
						liftPIControlLvl6AndUp(level15Height);
					}

					SensorValue[rollerEnc] = 0;

					moveArmBackLvl1and2();
					break;
				}
			}
		}

		//FOR SECOND REMOTE
		//Move Lift Up and Down

		if (!boingyPointOn) {
			/*if ((abs(vexRT[Ch3Xmtr2]) > MIN_JOYSTICK_THRESHOLD)) {
			motorReq2[swingingArm] = vexRT[Ch3Xmtr2];
			} else {
			motorReq2[swingingArm] = 0;
			}*/

			if (isButtonPressed(Btn7LXmtr2)) {
				armBack = false;
				armFront = true;
				} else if (isButtonPressed(Btn7RXmtr2)) {
				armFront = false;
				armBack = true;
			}

			if (armFront) {
				moveArmForward();
				} else if (armBack) {
				moveArmBackLvl1and2();
			}
		}

		if ((abs(vexRT[Ch2Xmtr2]) > MIN_JOYSTICK_THRESHOLD)) {
			motor[mobileGoal] = vexRT[Ch2Xmtr2];
			} else {
			motor[mobileGoal] = 0;
		}

		if (!boingyPointOn) {
			if (isButtonPressed(Btn5UXmtr2)) {
				motor[roller] = 100;
				} else if (isButtonPressed(Btn5DXmtr2)) {
				motor[roller] = -100;
				} else {
				motor[roller] = 25;
			}
		}

		if (isButtonClick(Btn8UXmtr2)) {
			theaterChaseTask(127, 0, 127, 127, 15000);
		}

		if (isButtonClick(Btn8RXmtr2)) {
			theaterChaseTask(0, 0, 127, 127, 15000);
		}

		if (isButtonClick(Btn8LXmtr2)) {
			theaterChaseTask(127, 0, 0, 127, 15000);
		}


		// --- Choose alliance if both Left & Right LCD Buttons are pressed

		if ((nLCDButtons & (kButtonLeft | kButtonRight)) == (kButtonLeft | kButtonRight)) {
			selectTeamAlliance();
		}

		wait1Msec(15);

		//writeDebugStreamLine ("liftRightPot, %d", SensorValue[liftRightPot]);
		//writeDebugStreamLine ("armPot, %d", SensorValue[armPot]);
		//writeDebugStreamLine ("liftLeftPot, %d", SensorValue[liftLeftPot]);
		writeDebugStreamLine ("mobilePot, %d", SensorValue[mobilePot]);

		//writeDebugStreamLine ("Preset level Active %d", presetLevelActive)
		//writeDebugStreamLine ("presetLevel %d", presetLevel);
		//writeDebugStreamLine ("leftDriveEnc, %d", SensorValue[leftDriveEnc]);
		//writeDebugStreamLine ("rightDriveEnc, %d", SensorValue[rightDriveEnc]);
		//	writeDebugStreamLine ("rollerEnc, %d", SensorValue[rollerEnc]);

		//writeDebugStreamLine ("Level Auto Active %d", presetLevelActive);
		//writeDebugStreamLine ("Arm Back Level %d", armIsBackLvl1and2);
		//writeDebugStreamLine ("Arm Forward Level %d", armIsForward);
		//	writeDebugStreamLine("Roller Intaking %d", rollerIntaking);
		//writeDebugStreamLine("Arm Is Back %d", armIsBackLvl1and2);
		//	writeDebugStreamLine("Lift Is Down %d", liftIsDown);

		/*writeDebugStreamLine("Left Current %d", leftCurrent);
		writeDebugStreamLine("Right Current %d", rightCurrent);
		writeDebugStreamLine("lift left error %d", liftLeftError);
		writeDebugStreamLine("Right Current %d", liftRightError);*/

		//writeDebugStreamLine("Roller Encoder %d", SensorValue[rollerEnc]);

	//	datalogAddValueWithTimeStamp(1, SensorValue[liftLeftPot]);
		//datalogAddValueWithTimeStamp(2, SensorValue[liftRightPot]);
	//	datalogAddValueWithTimeStamp(3, liftLeftError);
		//datalogAddValueWithTimeStamp(4, liftRightError);
	//	datalogAddValueWithTimeStamp(5, leftCurrent);
		//datalogAddValueWithTimeStamp(6, rightCurrent);
	//	datalogAddValueWithTimeStamp(0, leftErrorT);
	}
}

task usercontrol()
{
	robotMode = USER_CONTROL;

	if (false) UserControlCodePlaceholderForTesting();	// complains if I remove this

	writeDebugStreamLine("Starting User Control...");
	writeDebugStreamLine("Main battery level: %3.2f", nAvgBatteryLevel * 0.001);
	writeDebugStreamLine("Backup battery level: %3.2f", BackupBatteryLevel * 0.001);

	initialize();

	//startTask(shooterControl);

	startTask(MotorSlewRateTask);
	//startTask(MotorSlewRateTask2);
	startTask(ProcessController);

	/*while (true) {
	processController();
	waitInMilliseconds(5);
	}*/
}

void initialize()
{
	// Library routines thread
	startTask(activateLib);

	// LED strip routines thread
	setupLedStrip();

	SensorValue[rightDriveEnc] = 0;
	SensorValue[leftDriveEnc] = 0;
	SensorValue[rollerEnc] = 0;

	datalogClear();

	presetLevel = PRESET_LEVEL_ONE;
}

void timerCallback(unsigned int timerId)
{

}

void selectTeamAlliance()
{
	// Defaults
	allianceColor = BLUE_ALLIANCE;
	allianceSide = RIGHT;
	autonomousMode = AUTONOMOUS_MODE_CUBE;
	//return;

	//SensorValue[ledGreen] = 0;
	//SensorValue[ledRed] = 0;

	// Zero out encoder positions

	// Clear LCD and turn on backlight
	clearLCDLine(0);
	clearLCDLine(1);
	bLCDBacklight = true;

	// Display alliance selection
	displayLCDString(0, 0, " Team Color  ");
	displayLCDString(1, 0, " Blue       Red ");

	bool allianceSelected = false;
	while (!allianceSelected) {	//bIfiRobotDisabled
		// Wait for button press
		switch (getLcdButtons()) {
		case kButtonLeft:
			allianceColor = BLUE_ALLIANCE;
			displayLCDString(1, 0, "[Blue]      Red ");
			allianceSelected = true;
			break;

		case kButtonRight:
			allianceColor = RED_ALLIANCE;
			displayLCDString(1, 0, "Blue       [Red]");
			allianceSelected = true;
			break;
		}

		wait1Msec(10);
	}

	// Display autonomous selection
	wait1Msec(500);

	// Display alliance selection
	displayLCDString(0, 0, " Team Side  ");
	displayLCDString(1, 0, " Left     Right ");

	bool sideSelected = false;
	while (!sideSelected) {	//bIfiRobotDisabled
		// Wait for button press
		switch (getLcdButtons()) {
		case kButtonLeft:
			allianceSide = LEFT;
			displayLCDString(1, 0, "[Left]    Right ");
			sideSelected = true;
			break;

		case kButtonRight:
			allianceSide = RIGHT;
			displayLCDString(1, 0, "Left     [Right]");
			sideSelected = true;
			break;
		}

		wait1Msec(10);
	}

	// Display autonomous selection
	wait1Msec(500);

	displayLCDString(0, 0, "Autonomous Mode ");
	displayLCDString(1, 0, "Full  Min  None ");

	bool autonomousSelected = false;
	int scrollCount = 1;
	byte scrolledAuto = AUTONOMOUS_MODE_CUBE;
	while (!autonomousSelected) {
		// Wait for button press
		if(nLCDButtons == 1) {
			scrollCount -= 1;
		}
		if(nLCDButtons == 4) {
			scrollCount += 1;
		}
		if(nLCDButtons == 2) {
			autonomousMode = scrolledAuto;
			autonomousSelected = true;
		}

		switch (scrollCount) {
		case 1:
			scrolledAuto = AUTONOMOUS_MODE_CUBE;
			displayLCDString(1, 0, "[1]2 3 4 5 6 7 8 ");
			wait1Msec(200);
			break;

		case 2:
			scrolledAuto = AUTONOMOUS_MODE_CUBE_BACK_STAR;
			displayLCDString(1, 0, " 1[2]3 4 5 6 7 8 ");
			wait1Msec(200);
			break;

		case 3:
			scrolledAuto = AUTONOMOUS_MODE_FENCE;
			displayLCDString(1, 0, " 1 2[3]4 5 6 7 8 ");
			wait1Msec(200);
			break;

		case 4:
			scrolledAuto = AUTONOMOUS_MODE_SKILLS;
			displayLCDString(1, 0, " 1 2 3[4]5 6 7 8 ");
			wait1Msec(200);
			break;

		case 5:
			scrolledAuto = AUTONOMOUS_MODE_STACK_DRIVE;
			displayLCDString(1, 0, " 1 2 3 4[5]6 7 8 ");
			wait1Msec(200);
			break;

		case 6:
			scrolledAuto = AUTONOMOUS_MODE_STACK_PIPE;
			displayLCDString(1, 0, " 1 2 3 4 5[6]7 8 ");
			wait1Msec(200);
			break;

		case 7:
			scrolledAuto = AUTONOMOUS_MODE_STACK_BACK;
			displayLCDString(1, 0, " 1 2 3 4 5 6[7]8 ");
			wait1Msec(200);
			break;

		case 8:
			scrolledAuto = AUTONOMOUS_MODE_DRIVE_BLOCK;
			displayLCDString(1, 0, " 1 2 3 4 5 6 7[8]");
			wait1Msec(200);
			break;
		}

		wait1Msec(10);
	}

	wait1Msec(500);

	// Clear LCD
	clearLCDLine(0);
	clearLCDLine(1);
}

void moveArmForward () {
	if (SensorValue[armPot] > 80) {
		motor[swingingArm] = 120;
		} else if (SensorValue[armPot] <= 80) {
		motor[swingingArm] = 0;
	}
}

void moveArmBack () {
	if (SensorValue[armPot] < 1100){
		motor[swingingArm] = -127;
		} else if (SensorValue[armPot] >= 1100 && SensorValue[armPot] < 2000) {
		motor[swingingArm] = -127;
		} else if (SensorValue[armPot] >= 2000 && SensorValue[armPot] < 2600  - (armError/2)) {
		motor[swingingArm] = -65;
		} else if (SensorValue[armPot] >= 2800 && SensorValue[armPot] < 2890  - (armError/2)) {
		motor[swingingArm] = -30;
		} else if (SensorValue[armPot] >= 2890 + (armError/2) && SensorValue[armPot] < 3100) {
		motor[swingingArm] = 60;
		} else if (SensorValue[armPot] >= 3100 && SensorValue[armPot] < 3750) {
		motor[swingingArm] = 80;
		} else if (SensorValue[armPot] >= 3750) {
		motor[swingingArm] = 100;
	}
}

void moveLiftDown() {
	if (SensorValue[liftLeftPot] > 10 && SensorValue[liftRightPot] > 10) {
		motor[liftL] = -127;
		motor[liftR] = -127;
		} else {
		motor[liftL] = 0;
		motor[liftR] = 0;
	}
}

void moveLiftUp4(int height) {
	/*if (SensorValue[liftLeftPot] < (height - 90)){
	motor[liftL] = 127;
	} else if (SensorValue[liftLeftPot] >= (height - 90) && SensorValue[liftLeftPot] < (height - 60)) {
	motor[liftL] = 100;
	} else if (SensorValue[liftLeftPot] >= (height - 60) && SensorValue[liftLeftPot] < (height - 30)) {
	motor[liftL] = 60;
	} else if (SensorValue[liftLeftPot] >= (height - 30) && SensorValue[liftLeftPot] < (height - 15)) {
	motor[liftL] = 30;
	} else if (SensorValue[liftLeftPot] >= (height - 15) && SensorValue[liftLeftPot] < height - (liftError/2)) {
	motor[liftL] = 15;
	} else if (SensorValue[liftLeftPot] <= height + (liftError/2) && SensorValue[liftLeftPot] > height - (liftError/2)) {
	motor[liftL] = 0;
	} else if (SensorValue[liftLeftPot] >= height + (liftError/2) && SensorValue[liftLeftPot] < (height + 60)) {
	motor[liftL] = -15;
	} else if (SensorValue[liftLeftPot] >= (height + 60) && SensorValue[liftLeftPot] < (height + 100)) {
	motor[liftL] = -30;
	} else if (SensorValue[liftLeftPot] >= (height + 100) && SensorValue[liftLeftPot] < (height + 300)) {
	motor[liftL] = -60;
	} else if (SensorValue[liftLeftPot] >= (height + 300) && SensorValue[liftLeftPot] < (height + 700)) {
	motor[liftL] = -100;
	} else if (SensorValue[liftLeftPot] >= (height + 700) && SensorValue[liftLeftPot] < (height + 1060)) {
	motor[liftL] = -127;
	}

	if (SensorValue[liftRightPot] < (height - 90)){
	motor[liftR] = 127;
	} else if (SensorValue[liftRightPot] >= (height - 90) && SensorValue[liftRightPot] < (height - 60)) {
	motor[liftR] = 100;
	} else if (SensorValue[liftRightPot] >= (height - 60) && SensorValue[liftRightPot] < (height - 30)) {
	motor[liftR] = 60;
	} else if (SensorValue[liftRightPot] >= (height - 30) && SensorValue[liftRightPot] < (height - 15)) {
	motor[liftR] = 30;
	} else if (SensorValue[liftRightPot] >= (height - 15) && SensorValue[liftRightPot] < height - (liftError/2)) {
	motor[liftR] = 15;
	} else if (SensorValue[liftRightPot] <= height + (liftError/2) && SensorValue[liftRightPot] > height - (liftError/2)) {
	motor[liftR] = 0;
	} else if (SensorValue[liftRightPot] >= height + (liftError/2) && SensorValue[liftRightPot] < (height + 60)) {
	motor[liftR] = -15;
	} else if (SensorValue[liftRightPot] >= (height + 60) && SensorValue[liftRightPot] < (height + 100)) {
	motor[liftR] = -30;
	} else if (SensorValue[liftRightPot] >= (height + 100) && SensorValue[liftRightPot] < (height + 300)) {
	motor[liftR] = -60;
	} else if (SensorValue[liftRightPot] >= (height + 300) && SensorValue[liftRightPot] < (height + 700)) {
	motor[liftL] = -100;
	} else if (SensorValue[liftRightPot] >= (height + 700) && SensorValue[liftRightPot] < (height + 1060)) {
	motor[liftR] = -127;
	}

	savedValueHeight4 = height;*/
}

void moveLiftUp5(int height) {
	if (SensorValue[liftLeftPot] < (height - 90)){
		motor[liftL] = 100;
		} else if (SensorValue[liftLeftPot] >= (height - 90) && SensorValue[liftLeftPot] < (height - 15)) {
		motor[liftL] = 30;
		} else if (SensorValue[liftLeftPot] >= (height - 15) && SensorValue[liftLeftPot] < height - (liftError/2)) {
		motor[liftL] = 25;
		} else if (SensorValue[liftLeftPot] <= height + (liftError/2) && SensorValue[liftLeftPot] > height - (liftError/2)) {
		motor[liftL] = 0;
		} else if (SensorValue[liftLeftPot] >= height + (liftError/2) && SensorValue[liftLeftPot] < (height + 60)) {
		motor[liftL] = -30;
		} else if (SensorValue[liftLeftPot] >= (height + 60) && SensorValue[liftLeftPot] < (height + 360)) {
		motor[liftL] = -50;
		} else if (SensorValue[liftLeftPot] >= (height + 360) && SensorValue[liftLeftPot] < (height + 1060)) {
		motor[liftL] = -100;
	}

	if (SensorValue[liftRightPot] < (height - 90)){
		motor[liftR] = 100;
		} else if (SensorValue[liftRightPot] >= (height - 90) && SensorValue[liftRightPot] < (height - 15)) {
		motor[liftR] = 30;
		} else if (SensorValue[liftRightPot] >= (height - 15) && SensorValue[liftRightPot] < height - (liftError/2)) {
		motor[liftR] = 25;
		} else if (SensorValue[liftRightPot] <= height + (liftError/2) && SensorValue[liftRightPot] > height - (liftError/2)) {
		motor[liftR] = 0;
		} else if (SensorValue[liftRightPot] >= height + (liftError/2) && SensorValue[liftRightPot] < (height + 60)) {
		motor[liftR] = -30;
		} else if (SensorValue[liftRightPot] >= (height + 60) && SensorValue[liftRightPot] < (height + 360)) {
		motor[liftL] = -50;
		} else if (SensorValue[liftRightPot] >= (height + 360) && SensorValue[liftRightPot] < (height + 1060)) {
		motor[liftR] = -100;
	}

	savedValueHeight = height;
}

void moveArmBackLvl1and2() {
	/*
	if (SensorValue[armPot] < armPotPosition - 710){
	motor[swingingArm] = -127;
	} else if (SensorValue[armPot] >= armPotPosition - 710 && SensorValue[armPot] < armPotPosition - 330) {
	motor[swingingArm] = -70;
	} else if (SensorValue[armPot] >= armPotPosition - 330 && SensorValue[armPot] < armPotPosition - 160) {
	motor[swingingArm] = -50;
	} else if (SensorValue[armPot] >= armPotPosition - 160 && SensorValue[armPot] < armPotPosition - 100) {
	motor[swingingArm] = -30;
	} else if (SensorValue[armPot] >= armPotPosition - 100 && SensorValue[armPot] < armPotPosition - 50) {
	motor[swingingArm] = -20;
	} else if (SensorValue[armPot] >= armPotPosition - 50 && SensorValue[armPot] < armPotPosition /* - (armError/2)) {
	motor[swingingArm] = -10;
	//writeDebugStreamLine("To Far!!!");
	} else if (SensorValue[armPot] >= armPotPosition /*+ (armError/2) && SensorValue[armPot] < armPotPosition + 10) {
	motor[swingingArm] = 0;
	writeDebugStreamLine("Arm Is BAck Here!!!!");
	} else if (SensorValue[armPot] >= armPotPosition + 10 && SensorValue[armPot] < armPotPosition + 20) {
	motor[swingingArm] = 30;
	} else if (SensorValue[armPot] >= armPotPosition + 20 && SensorValue[armPot] < armPotPosition + 30) {
	motor[swingingArm] = 43;
	} else if (SensorValue[armPot] >= armPotPosition + 30 && SensorValue[armPot] < armPotPosition + 40) {
	motor[swingingArm] = 45;
	} else if (SensorValue[armPot] >= armPotPosition + 40 && SensorValue[armPot] < armPotPosition + 230) {
	motor[swingingArm] = 47;
	} else if (SensorValue[armPot] >= armPotPosition + 230 && SensorValue[armPot] < armPotPosition + 250) {
	motor[swingingArm] = 50;
	} else if (SensorValue[armPot] >= armPotPosition + 250 && SensorValue[armPot] < armPotPosition + 530) {
	motor[swingingArm] = 53;
	} else if (SensorValue[armPot] >= armPotPosition + 530 && SensorValue[armPot] < armPotPosition + 800) {
	motor[swingingArm] = 57;
	} else if (SensorValue[armPot] >= armPotPosition + 800) {
	motor[swingingArm] = 127;
	}
	if (SensorValue[armPot] >= armPotPosition + 10 && SensorValue[armPot] < armPotPosition + 40) {
	getToArmSpeed ++;
	} else {
	getToArmSpeed = 35;
	}*/
	//writeDebugStreamLine("Arm Speed %d", getToArmSpeed);*/
	if (SensorValue[armPot] < armPotPosition) {
		motor[swingingArm] = -127;
		} else if (SensorValue[armPot] >= armPotPosition) {
		motor[swingingArm] = 0;
		//writeDebugStreamLine("Arm Is BAck Here!!!!");
	}
}

void rollerIntake(int speed) {
	motor[roller] = speed;
	rollerSpeed = speed;
	//	writeDebugStreamLine("Set speed %d", rollerSpeed);
}

void rollerOutake(int speed) {
	motor[roller] = speed;
	if (speed >= 0) {
		rollerOutaking = false;
		} else if (speed < 0) {
		rollerOutaking = true;
	}
}

void checkPositions() {
	if (SensorValue[armPot] <= 60) {
		armIsForward = true;
		armIsBackLvl1and2 = false;
		armIsBack = false;
		} else {
		armIsForward = false;
	}
	if (SensorValue[armPot] >= armPotPosition + 160) {
		armIsBackLvl1and2 = true;
		} else {
		armIsBackLvl1and2 = false;
	}
	if (SensorValue[armPot] >= 2890 + (armError/2) && SensorValue[armPot] < 3100) {
		armIsBack = true;
		} else {
		armIsBack = false;
	}

	if (SensorValue[liftLeftPot] > 10 && SensorValue[liftRightPot] > 10) {
		liftIsDown = false;
		} else {
		liftIsDown = true;
	}

	/*if (SensorValue[liftLeftPot] <= level4Height + (liftError/2) && SensorValue[liftLeftPot] > level4Height - (liftError/2) && SensorValue[liftRightPot] <= level4Height + (liftError/2) && SensorValue[liftRightPot] > level4Height - (liftError/2)) {
	liftIsPosition4 = true;
	writeDebugStreamLine("True!!!");
	} else {
	liftIsPosition4 = false;
	}*/
	if (SensorValue[liftLeftPot] >= level5Height && SensorValue[liftRightPot] >= level5Height) {
		liftIsPosition5 = true;
		} else {
		liftIsPosition5 = false;
	}
	if (SensorValue[liftLeftPot] >= level6Height && SensorValue[liftRightPot] >= level6Height) {
		liftIsPosition6 = true;
		} else {
		liftIsPosition6 = false;
	}

	if (SensorValue[rollerEnc] > 0) {
		rollerIntaking = true;
		} else if (SensorValue[rollerEnc] < 0) {
		rollerIntaking = false;
	}

	/*if (rollerSpeed > 0 && SensorValue[rollerEnc] < 0) {
	SensorValue[rollerEnc] = 0;
	//	writeDebugStreamLine("Set to 0 1");
	}
	if (rollerSpeed < 0 && SensorValue[rollerEnc] > 0) {
	SensorValue[rollerEnc] = 0;
	//	writeDebugStreamLine("Set to 0 2");
	}

	if (SensorValue[rollerEnc] <= 0) {
	rollerRotationsOut = SensorValue[rollerEnc];
	}*/
	//SensorValue[liftRightPot] += 25;
	//writeDebugStreamLine("Roller Rotations %d", rollerRotationsOut);
}

void liftPIControl (float position) {
	//Find lift error
	liftLeftError = position - SensorValue[liftLeftPot];
	liftRightError = position - SensorValue[liftRightPot];

	leftProportion = liftLeftError * leftkp;
	rightProportion = liftRightError * rightkp;

	leftIntegral = leftErrorT * leftki;
	rightIntegral = rightErrorT * rightki;

	leftCurrent = leftProportion + leftIntegral;
	rightCurrent = rightProportion + rightProportion;

	//left
	//if (liftLeftError < integralAcitveZone) {
	leftErrorT += liftLeftError;
	//} else {
	//leftErrorT = 0;
	//}
	if (leftErrorT > 50/leftki) {
		leftErrorT = 50/leftki;
	}

	//right
	//if (liftRightError < integralAcitveZone) {
	rightErrorT += liftRightError;
	//} else {
	//rightErrorT = 0;
	//}
	if (rightErrorT > 50/rightki) {
		rightErrorT = 50/rightki;
	}

	if ((SensorValue[liftLeftPot] * 0.9158) <= position + (liftError/2) && (SensorValue[liftLeftPot] * 0.9158) > position - (liftError/2)) {
		//leftCurrent = 0;
		liftLeftIsPosition4 = true;
		writeDebugStreamLine("LEFT!!! %d", liftLeftIsPosition4);
		} else {
		liftLeftIsPosition4 = false;
	}

	if (SensorValue[liftRightPot] <= position + (liftError/2) && SensorValue[liftRightPot] > position - (liftError/2)) {
		//rightCurrent = 0;
		liftRightIsPosition4 = true;
		writeDebugStreamLine("RIGHT!!! %d", liftRightIsPosition4);
		} else {
		liftRightIsPosition4 = false;
	}

	motor[liftL] = leftCurrent;
	motor[liftR] = rightCurrent;
}

void liftPIControlLvl6AndUp (float position) {
	//Find lift error
	liftLeftError = position - SensorValue[liftLeftPot];
	liftRightError = position - SensorValue[liftRightPot];

	leftProportion = liftLeftError * leftkp;
	rightProportion = liftRightError * rightkp;

	leftIntegral = leftErrorT * leftki;
	rightIntegral = rightErrorT * rightki;

	leftCurrent = leftProportion + leftIntegral;
	rightCurrent = rightProportion + rightProportion;

	//left
	//if (liftLeftError < integralAcitveZone) {
	leftErrorT += liftLeftError;
	//} else {
	//leftErrorT = 0;
	//}
	if (leftErrorT > 50/leftki) {
		leftErrorT = 50/leftki;
	}

	//right
	//if (liftRightError < integralAcitveZone) {
	rightErrorT += liftRightError;
	//} else {
	//rightErrorT = 0;
	//}
	if (rightErrorT > 50/rightki) {
		rightErrorT = 50/rightki;
	}

	if ((SensorValue[liftLeftPot] * 0.9158) <= position + (liftError/2) && (SensorValue[liftLeftPot] * 0.9158) > position - (liftError/2)) {
		//leftCurrent = 0;
		liftLeftIsPosition4 = true;
		writeDebugStreamLine("LEFT!!! %d", liftLeftIsPosition4);
		} else {
		liftLeftIsPosition4 = false;
	}

	if (SensorValue[liftRightPot] <= position + (liftError/2) && SensorValue[liftRightPot] > position - (liftError/2)) {
		//rightCurrent = 0;
		liftRightIsPosition4 = true;
		writeDebugStreamLine("RIGHT!!! %d", liftRightIsPosition4);
		} else {
		liftRightIsPosition4 = false;
	}

	if (leftCurrent >= 70) {
		leftCurrent = 70;
	}
	if (leftCurrent <= -70) {
		leftCurrent = -70;
	}
	if (rightCurrent >= 70) {
		rightCurrent = 70;
	}
	if (rightCurrent <= -70) {
		rightCurrent = -70;
	}
	motor[liftL] = leftCurrent;
	motor[liftR] = rightCurrent;
}

//Auto Functions
void autoLiftControl (int height) {
	while (!liftRightIsPosition4) {
		liftPIControl(height);
	}
}

//Drive function for auto
void drive(int left, int right) {
	turnMotor(driveFL, left);
	turnMotor(driveFR, right);
	turnMotor(driveBL, left);
	turnMotor(driveBR, right);
}
//Drive function with encoders for auto
void driveForward(int speed, int distance) {
	while (SensorValue[rightDriveEnc] < distance && SensorValue[leftDriveEnc] < distance) {
		writeDebugStreamLine("Front Left Encoder: %d", SensorValue[leftDriveEnc]);
		writeDebugStreamLine("Front Right Encoder: %d", SensorValue[rightDriveEnc]);
		writeDebugStreamLine("Moving forward");
		drive(speed, speed);
	}
	drive(0, 0);

	SensorValue[rightDriveEnc] = 0;
	SensorValue[leftDriveEnc] = 0;
	writeDebugStreamLine("Front Left Encoder: %d", SensorValue[leftDriveEnc]);
	writeDebugStreamLine("Front Right Encoder: %d", SensorValue[rightDriveEnc]);
}

void driveBackward(int speed, int distance) {
	while (SensorValue[rightDriveEnc] > distance && SensorValue[leftDriveEnc] > distance) {
		drive(speed, speed);
	}
	drive(0, 0);

	SensorValue[rightDriveEnc] = 0;
	SensorValue[leftDriveEnc] = 0;
}

void clearDriveEnc() {
	SensorValue[rightDriveEnc] = 0;
	SensorValue[leftDriveEnc] = 0;
}

void moveMobileGoalOut() {
	while (SensorValue[mobilePot] > 20) {
		motor[mobileGoal] = 127;
	}
	motor[mobileGoal] = 0;
}

void moveMobileGoalIn() {
	while (SensorValue[mobilePot] < 3900) {
		motor[mobileGoal] = -127;
	}
	motor[mobileGoal] = 0;
}
