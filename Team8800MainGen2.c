#pragma config(Sensor, in1,    armPot,         sensorPotentiometer)
#pragma config(Sensor, in5,    driveGyro,      sensorGyro)
#pragma config(Sensor, dgtl1,  rightDriveEnc,  sensorQuadEncoder)
#pragma config(Sensor, dgtl3,  leftDriveEnc,   sensorQuadEncoder)
#pragma config(Sensor, dgtl5,  liftEnc,        sensorQuadEncoder)
#pragma config(Sensor, dgtl7,  MOSI,           sensorDigitalOut)
#pragma config(Sensor, dgtl8,  SCLK,           sensorDigitalOut)
#pragma config(Sensor, dgtl9,  liftLimitSwitch, sensorTouch)
#pragma config(Motor,  port1,           shooter,       tmotorVex393_HBridge, openLoop)
#pragma config(Motor,  port2,           driveBL,       tmotorVex393HighSpeed_MC29, openLoop)
#pragma config(Motor,  port3,           driveBR,       tmotorVex393HighSpeed_MC29, openLoop, reversed, encoderPort, None)
#pragma config(Motor,  port4,           driveFR,       tmotorVex393HighSpeed_MC29, openLoop, reversed)
#pragma config(Motor,  port5,           driveFL,       tmotorVex393HighSpeed_MC29, openLoop)
#pragma config(Motor,  port6,           swingingArm,   tmotorVex393TurboSpeed_MC29, openLoop)
#pragma config(Motor,  port7,           liftR,         tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port8,           liftL,         tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port10,          roller,        tmotorVex393_HBridge, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

// Declare VEX as the robot platform

#pragma platform(VEX)

// Competition Control and Duration Settings
#pragma competitionControl(Competition)
#pragma autonomousDuration(20)
#pragma userControlDuration(120)

#include "Vex_Competition_Includes.c"   //Main competition background code...do not modify!

// **** Important programmer notes ****
//
// When upgrading ROBOTC the Robot Platform Settings are lost and must be reset
// otherwise compiler error will result. Ensure the following are set:
// 		Robot -> Platform Type -> VEX 2.0 Cortex
// 		Robot -> Platform Type -> VEX Robotics -> VEX 2.0 Cortex
// 		Robot -> Platform Type -> Natural Language (PLTW)
//
//
// Note: Sometime when upgrading FW on the controller and/or joystick, the FW for the
//       VEXNet Keys must also be upgraded. The symptom of needing this upgrade is a
//       failure of the controller and joystick to communicate with each other.
//
//
// Note: When RobotC refuses to download code to the robot, first try manually selecting the
//       COM port. If that doesn't work then it may be necessary reload the firmware. First
//       update the main FW and then the RobotC FW. Don't forget to rename robot afterwards.
//
//
// Variable info:
//
//		int, short, word - 2 bytes
//		long - 4 bytes
//		SensorValue() returns 2 byte value

// Control debugger windows by defining these pragmas
#pragma DebuggerWindows("debugStream")

#include "Team8800Lib.c"		// Utility routines to simplify programming
#include "Team8800Led.c"		// Routines to control the LED strip
#include "MultiTask.c"  // Motor slew control

// Delcarations

int number = 10;

// Initialize
void initialize();
void initializeGyro();
void selectTeamAlliance();

// Controller Input
//void processController();

// Autonomous
//void autonomousRoutines();

// Robot Action

//Functions
void moveLiftDown(int speed, int distance);
void moveArmOut();
void moveArmMiddle();
void moveArmFlag();
void moveArmIn();
void moveArm(bool forward);
void moveLiftUp(int speed, int distance);
void moveLiftUpAuto(int speed, int distance);
void rollerIntake(int speed);
void rollerOutake(int speed, int time);

void autoLiftPIDControl (int position);
void liftPIDCalculate (int position);
void liftPIDControl(int position);
void checkLiftPos (int height);
void autoDrivePIDCalculate (int distance, bool time);
void autoDrivePIDControl (int distance, bool time);
void autoGyroPIDCalculate (int setAngle);
void autoGyroPIDControl (int setAngle);
void autoDriveGyroPIDCalculate (int setAngle, int distance);
void autoDriveGyroPIDControl (int setAngle, int distance);

//Auto Functions
void drive(int left, int right);
void driveForward(int speed, int distance);
void driveBackward(int speed, int distance);
void turnLeft(int speed, int distance);
void turnRight(int speed, int distance);
void clearDriveEnc();
void allignWithFlags();
void collectFirstBall();
void scoreHighFlag();
void scoreBottomTwoFlags();
void skillsStuff();

// Constants and global vars
const byte MIN_JOYSTICK_THRESHOLD = 30;

const byte RED_ALLIANCE = 1;
const byte BLUE_ALLIANCE = 2;
byte allianceColor = BLUE_ALLIANCE;

const byte LEFT = 1;
const byte RIGHT = 2;
byte allianceSide = RIGHT;

const byte AUTONOMOUS_MODE_3FLAG = 1;
const byte AUTONOMOUS_MODE_1FLAG_PARK = 2;
const byte AUTONOMOUS_MODE_BACK_1FLAG = 3;
const byte AUTONOMOUS_MODE_BACK_1FLAG_PARK = 4;
const byte AUTONOMOUS_MODE_BLOCK = 5;
const byte AUTONOMOUS_MODE_SKILLS = 6;
byte autonomousMode = AUTONOMOUS_MODE_3FLAG;

unsigned long autonomousStartTime;

const byte AUTONOMOUS = 1;
const byte USER_CONTROL = 2;
byte robotMode = 1;

bool presetLevelActive = false;
bool presetLevelJustActive = false;

bool armIsForward;
bool liftIsDown = false;

bool liftAtPosition;
bool driveAtPosition;
bool turnAtPosition;

bool rollerIntaking = false;
bool outakeFinished = false;

bool btnSixUPressed = false;
bool btnSixDPressed = false;

bool presetLevelScrollUp = false;
bool presetLevelScrollDown = false;

bool timeUp = false;

int autoStackExraHeight = 100;
int autoStackOutTime = 450;
int autoStackDownTime = 300;

int stackLevel = 1;
int autoStacklvl = 4;
int prevStackLevel = 0;

int liftLeftPositionError = 65;
int liftRightPositionError = 65;
int drivePositionError = 1;
int turnPositionError = 1;
int turnDrivePositionError = 2;
int driveTurnPositionError = 200;
int armError = 2;

//Lift Auto Proportional
float autoLiftkp = 0.35;

//Lift PID values
float liftkp = 0.63;
float liftki = 0.04;
float liftkd = -0.05;

//Drive PID values
float drivekp = 0.85;
float driveki = 0.000016;
float drivekd = 0.1;

//Turn PID values
float turnkp = 0.65;
float turnki = 0.0027;
float turnkd = 0.04;

//Turn Drive PID values
float turnDrivekp;
float turnDriveki;
float turnDrivekd;

//Drive Turn PID values
float driveTurnkp = 0.75;
float driveTurnki;
float driveTurnkd;

float turnError;

int driveCurrent;
int gyroCurrent;
int overallCurrentLeft;
int overallCurrentRight;

int maxTurnPower = 15;

int rollerSpeed;

void pre_auton()
{
	bStopTasksBetweenModes = true;

	clearDebugStream();
	writeDebugStreamLine("Pre-Autonomous...");

	initializeGyro();

	// Select alliance using LCD and indicate selection with LEDs
	selectTeamAlliance();
}

task autonomousRoutines()
{
	switch (autonomousMode) {
	case AUTONOMOUS_MODE_3FLAG:
		//////////////////////////////////////////////////////////////3 Flag////////////////////////

		if (allianceColor == BLUE_ALLIANCE) {
			theaterChaseTask(0, 0, 127, 50, 15000);
			} else {
			theaterChaseTask(127, 0, 0, 50, 15000);
		}

		clearTimer(T2);
		clearDriveEnc();

		collectFirstBall();

		clearTimer(T2);
		clearDriveEnc();

		allignWithFlags();

		clearTimer(T2);
		clearDriveEnc();
		wait1Msec(100);

		scoreHighFlag();

		clearTimer(T2);
		clearDriveEnc();
		wait1Msec(100);

		scoreBottomTwoFlags();

		///////////////////////////////////////////////////////////////////////End 3FLAG//////////////////////////
		break;

	case AUTONOMOUS_MODE_1FLAG_PARK:
		/////////////////////////////////////////////////////////////////////////////Skills///////////////////////////////////////////


		if (allianceColor == BLUE_ALLIANCE) {
			theaterChaseTask(0, 0, 127, 50, 15000);
			} else {
			theaterChaseTask(127, 0, 0, 50, 15000);
		}

		clearTimer(T2);
		clearDriveEnc();

		collectFirstBall();

		clearTimer(T2);
		clearDriveEnc();

		allignWithFlags();

		clearTimer(T2);
		clearDriveEnc();
		wait1Msec(100);

		scoreHighFlag();

		clearTimer(T2);
		clearDriveEnc();
		wait1Msec(100);

		scoreBottomTwoFlags();

		clearTimer(T2);
		clearDriveEnc();

		skillsStuff();

		//////////////////////////////////////////////////////End of Skills/////////////////////////////////
		break;

	case AUTONOMOUS_MODE_BACK_1FLAG:
		////////////////////////////////////////////////////////////////////////////////Mobile Goal 20/////////////////////////////
		clearDriveEnc();
		clearTimer(T2);

		clearDriveEnc();
		clearTimer(T2);


		if (allianceColor == BLUE_ALLIANCE) {
			theaterChaseTask(0, 0, 127, 50, 15000);
			} else {
			theaterChaseTask(127, 0, 0, 50, 15000);
		}

		//////////////////////////////////////////////////////End of Mobile Goal 20/////////////////////////////////////////////////////
		break;

	case AUTONOMOUS_MODE_BACK_1FLAG_PARK:
		//////////////////////////////////////////////////////////Stationary/////////////////////////////////////
		motor[roller] = 40;

		clearDriveEnc();
		clearTimer(T2);

		clearDriveEnc();
		clearTimer(T2);

		if (allianceColor == BLUE_ALLIANCE) {
			theaterChaseTask(0, 0, 127, 50, 15000);
			} else {
			theaterChaseTask(127, 0, 0, 50, 15000);
		}

		///////////////////////////////////////////////////////////////End of Stationary///////////////////////////////////////////
		break;

	case AUTONOMOUS_MODE_BLOCK:
		/////////////////////////////////////////////////////////////Block/////////////////////////////////////////////////////



		if (allianceColor == BLUE_ALLIANCE) {
			theaterChaseTask(0, 0, 127, 50, 15000);
			} else {
			theaterChaseTask(127, 0, 0, 50, 15000);
		}

		/////////////////////////////////////////////////////////////End of Block/////////////////////////////////////////////////////
		break;

	case AUTONOMOUS_MODE_SKILLS:
		/////////////////////////////////////////////////////////////////////////////Skills////////////////////////////////

		clearDriveEnc();
		clearTimer(T2);

		clearDriveEnc();
		clearTimer(T2);

		clearDriveEnc();
		clearTimer(T2);


		if (allianceColor == BLUE_ALLIANCE) {
			theaterChaseTask(0, 0, 127, 50, 15000);
			} else {
			theaterChaseTask(127, 0, 0, 50, 15000);
		}

		//////////////////////////////////////////////////////////End of Skills/////////////////////////////////////////////
		break;
	}
}

task autonomous()
{
	robotMode = AUTONOMOUS;

	autonomousStartTime = nSysTime;
	writeDebugStreamLine("Starting Autonomous...");

	initialize();

	if (false) AutonomousCodePlaceholderForTesting();  // complains if I remove this

	startTask(autonomousRoutines);
}

task ProcessController() {
	while(true) {

		/*
		Main Controller:
		joysticks = drive
		8U mobile goal full out
		8D mobile goal full in
		8L mobile goal partial in
		8R mobile goal partial out

		Partner Contorller:
		5U lift up
		5D lift down
		6D roller out
		6U roller in
		7U
		7D stop auto stacking and reset to level 1
		7L lift at mobile goal height
		7R
		8U acivate current level
		8D activate last level
		8L arm out
		8R arm in

		*/

		// --- Joysticks to control robot driving (main controller only)

		static byte rightJoystickY, leftJoystickY, prevRightJoystickY = 0, prevLeftJoystickY = 0;

		rightJoystickY = readRightJoystickYAxis();
		leftJoystickY = readLeftJoystickYAxis();

		static bool rightDriveMoving = false;
		if (abs(rightJoystickY) > MIN_JOYSTICK_THRESHOLD) {
			rightDriveMoving = true;
			motorReq2[driveFR] = rightJoystickY;
			motorReq2[driveBR] = rightJoystickY;
			writeDebugStreamLine("Right: %d%%", rightJoystickY);
			} else {
			rightDriveMoving = false;
			motorReq2[driveFR] = 0;
			motorReq2[driveBR] = 0;
		}

		static bool leftDriveMoving = false;
		if (abs(leftJoystickY) > MIN_JOYSTICK_THRESHOLD) {
			leftDriveMoving = true;
			motorReq2[driveFL] = leftJoystickY;
			motorReq2[driveBL] = leftJoystickY;
			writeDebugStreamLine("Left: %d%%", leftJoystickY);
			} else {
			leftDriveMoving = false;
			motorReq2[driveFL] = 0;
			motorReq2[driveBL] = 0;
		}

		//Roller control
		if (isButtonPressed(Btn5U)) {
			motor[roller] = 127;
			} else if (isButtonPressed(Btn6U)) {
			motor[roller] = -127;
			} else {
			motor[roller] = 0;
		}

		//shooter control
		if (isButtonPressed(Btn8D)) {
			motor[shooter] = -127;
			} else if (isButtonPressed(Btn8U)) {
			motor[shooter] = 127;
			} else {
			motor[shooter] = 0;
		}

		//Arm control
		if (isButtonPressed(Btn8LXmtr2)) {
			moveArmIn();
			} else if (isButtonPressed(Btn8RXmtr2)) {
			moveArmOut();
			} else if (isButtonPressed(Btn8UXmtr2)) {
			moveArmMiddle();
			} else if (isButtonPressed(Btn8DXmtr2)) {
			moveArmFlag();
		}

		//Move lift
		if (isButtonPressed(Btn5UXmtr2)) {
			motor[liftL] = 127;
			motor[liftR] = 127;
			//liftPIDControl(1000);
			} else if (isButtonPressed(Btn5DXmtr2)) {
			motor[liftL] = -127;
			motor[liftR] = -127;
			//liftPIDControl(500);
			} else if (isButtonPressed(Btn7LXmtr2)) {
			autoLiftPIDControl(700);
			} else {
			motor[liftL] = 0;
			motor[liftR] = 0;
		}

		//writeDebugStreamLine("stack level %d", stackLevel);
		//writeDebugStreamLine("Prev stack level, %d", prevStackLevel);
		//writeDebugStreamLine("mobile,                                                                           %d", SensorValue[mobilePot]);
		//writeDebugStreamLine("               roller Enc, %d", SensorValue[rollerEnc]);
		//writeDebugStreamLine("arm pot,                                                    %d", SensorValue[armPot]);
		//writeDebugStreamLine("arm power,                                                    %d", armPower );
		//writeDebugStreamLine("left pot, %d", SensorValue[liftLeftPot]);
		//writeDebugStreamLine("right pot,                    %d", SensorValue[liftRightPot]);
		//writeDebugStreamLine("Increase Stack level,                    %d", increaseStackLvl);


		//writeDebugStreamLine("right drive enc                    %d", SensorValue[rightDriveEnc]);
		//	writeDebugStreamLine("left drive enc        %d", SensorValue[leftDriveEnc]);

		//writeDebugStreamLine("Gyro Values,      %d", SensorValue(driveGyro));
		//writeDebugStreamLine("Lift right pot,      %d", SensorValue(liftRightPot));
		//writeDebugStreamLine("						Lift Left pot,      %d", SensorValue(liftLeftPot));

		//datalogAddValueWithTimeStamp(6, SensorValue[liftLeftPot]);
		//datalogAddValueWithTimeStamp(5, SensorValue[liftRightPot]);
	//	datalogAddValueWithTimeStamp(6, SensorValue[armPot]);

		//datalogAddValueWithTimeStamp(0, SensorValue[liftLeftPot]);
		//datalogAddValueWithTimeStamp(1, SensorValue[liftRightPot]);

		if (isButtonClick(Btn7U) || isButtonClick(Btn7UXmtr2)) {
			theaterChaseTask(127, 0, 127, 127, 15000);
		}

		if (isButtonClick(Btn7R) || isButtonClick(Btn7RXmtr2)) {
			theaterChaseTask(0, 0, 127, 127, 15000);
		}

		if (isButtonClick(Btn7L) || isButtonClick(Btn7LXmtr2)) {
			theaterChaseTask(127, 0, 0, 127, 15000);
		}

		if (isButtonClick(Btn7D) || isButtonClick(Btn7DXmtr2)) {
			rainbowCycleTask(0, 15000);
		}

		// --- Choose alliance if both Left & Right LCD Buttons are pressed

		if ((nLCDButtons & (kButtonLeft | kButtonRight)) == (kButtonLeft | kButtonRight)) {
			selectTeamAlliance();
		}

		//writeDebugStreamLine("value Arm pot %d", SensorValue[armPot]);

		wait1Msec(15);
	}
}

task usercontrol()
{
	robotMode = USER_CONTROL;

	if (false) CodePlaceholderForTesting();	// complains if I remove this

	writeDebugStreamLine("Starting User Control...");
	writeDebugStreamLine("Main battery level: %3.2f", nAvgBatteryLevel * 0.001);
	writeDebugStreamLine("Backup battery level: %3.2f", BackupBatteryLevel * 0.001);

	initialize();

	startTask(MotorSlewRateTask);
	startTask(ProcessController);
}

void initialize()
{
	// Library routines thread
	startTask(activateLib);

	// LED strip routines thread
	setupLedStrip();

	//Clear Sensors
	SensorValue[rightDriveEnc] = 0;
	SensorValue[leftDriveEnc] = 0;
	SensorValue[liftEnc] = 0;

	datalogClear();
}

void timerCallback(unsigned int timerId)
{

}

void selectTeamAlliance()
{
	// Defaults
	allianceColor = BLUE_ALLIANCE;
	allianceSide = RIGHT;
	autonomousMode = AUTONOMOUS_MODE_3FLAG;
	//return;

	//SensorValue[ledGreen] = 0;
	//SensorValue[ledRed] = 0;

	// Zero out encoder positions

	// Clear LCD and turn on backlight
	clearLCDLine(0);
	clearLCDLine(1);
	bLCDBacklight = true;

	// Display alliance selection
	displayLCDString(0, 0, " Team Color  ");
	displayLCDString(1, 0, " Blue       Red ");

	bool allianceSelected = false;
	while (!allianceSelected) {	//bIfiRobotDisabled
		// Wait for button press
		switch (getLcdButtons()) {
		case kButtonLeft:
			allianceColor = BLUE_ALLIANCE;
			displayLCDString(1, 0, "[Blue]      Red ");
			allianceSelected = true;
			break;

		case kButtonRight:
			allianceColor = RED_ALLIANCE;
			displayLCDString(1, 0, "Blue       [Red]");
			allianceSelected = true;
			break;
		}

		wait1Msec(10);
	}

	// Display autonomous selection
	wait1Msec(500);

	// Display alliance selection
	displayLCDString(0, 0, " Team Side  ");
	displayLCDString(1, 0, " Left     Right ");

	bool sideSelected = false;
	while (!sideSelected) {	//bIfiRobotDisabled
		// Wait for button press
		switch (getLcdButtons()) {
		case kButtonLeft:
			allianceSide = LEFT;
			displayLCDString(1, 0, "[Left]    Right ");
			sideSelected = true;
			break;

		case kButtonRight:
			allianceSide = RIGHT;
			displayLCDString(1, 0, "Left     [Right]");
			sideSelected = true;
			break;
		}
		wait1Msec(10);
	}

	// Display autonomous selection
	wait1Msec(500);

	displayLCDString(0, 0, "Autonomous Type ");
	//displayLCDString(1, 0, "Full  Min  None ");

	bool autonomousTypeSelected = false;
	int scrollCountType = 1;
	byte scrolledAutoType = AUTONOMOUS_MODE_3FLAG;
	while (!autonomousTypeSelected) {
		// Wait for button press
		if(nLCDButtons == 1) {
			scrollCountType -= 1;
		}
		if(nLCDButtons == 4) {
			scrollCountType += 1;
		}
		if(nLCDButtons == 2) {
			autonomousMode = scrolledAutoType;
			autonomousTypeSelected = true;
		}

		switch (scrollCountType) {
		case 1:
			scrolledAutoType = AUTONOMOUS_MODE_3FLAG;
			displayLCDString(1, 0, "[1]2 3 4 5 6 ");
			wait1Msec(200);
			break;

		case 2:
			scrolledAutoType = AUTONOMOUS_MODE_1FLAG_PARK;
			displayLCDString(1, 0, " 1[2]3 4 5 6 ");
			wait1Msec(200);
			break;

		case 3:
			scrolledAutoType = AUTONOMOUS_MODE_BACK_1FLAG;
			displayLCDString(1, 0, " 1 2[3]4 5 6 ");
			wait1Msec(200);
			break;

		case 4:
			scrolledAutoType = AUTONOMOUS_MODE_BACK_1FLAG_PARK;
			displayLCDString(1, 0, " 1 2 3[4]5 6 ");
			wait1Msec(200);
			break;

		case 5:
			scrolledAutoType = AUTONOMOUS_MODE_BLOCK;
			displayLCDString(1, 0, " 1 2 3 4[5]6 ");
			wait1Msec(200);
			break;

		case 6:
			scrolledAutoType = AUTONOMOUS_MODE_SKILLS;
			displayLCDString(1, 0, " 1 2 3 4 5[6]");
			wait1Msec(200);
			break;
		}

		wait1Msec(10);
	}

	wait1Msec(500);

	// Clear LCD
	clearLCDLine(0);
	clearLCDLine(1);

	//displayLCDString(1, 0, "Full  Min  None ");

	wait1Msec(500);

	// Clear LCD
	clearLCDLine(0);
	clearLCDLine(1);
}

void initializeGyro() {
	writeDebugStreamLine("Gyro before initialize %d", SensorValue[driveGyro]);

	SensorType(driveGyro) = sensorNone;
	wait1Msec(1000);
	SensorType(driveGyro) = sensorGyro;
	wait1Msec(2000);

	writeDebugStreamLine("Gyro after initialize %d", SensorValue[driveGyro]);
}

void moveArmIn () {
	if (SensorValue[armPot] < 3800) {
		motor[swingingArm] = 120;
		writeDebugStreamLine("swinging arm pot %d", SensorValue[armPot]);
		}else if (SensorValue[armPot] > 3900)  {
		motor[swingingArm] = -30;
		} else if (SensorValue[armPot] >= 3800 && SensorValue[armPot] <= 3900) {
		motor[swingingArm] = 0;
	}
}

void moveArmOut() {
	if (SensorValue[armPot] > 260) {
			motor[swingingArm] = -120;
		} else if (SensorValue[armPot] > 235) {
		motor[swingingArm] = -20;
		} else if (SensorValue[armPot] < 210) {
		motor[swingingArm] = 30;
		} else if (SensorValue[armPot] < 185) {
		motor[swingingArm] = 70;
		}	else {
		motor[swingingArm] = 0;
	}
}

void moveArmMiddle() {
	if (SensorValue[armPot] > 2200) {
			motor[swingingArm] = -60;
		}else if (SensorValue[armPot] > 2100) {
		motor[swingingArm] = -15;
		}else if (SensorValue[armPot] < 1900) {
		motor[swingingArm] = 120;
		} else if (SensorValue[armPot] < 2020) {
		motor[swingingArm] = 40;
		} else {
		motor[swingingArm] = 5;
	}
}

void moveArmFlag() {
	if (SensorValue[armPot] > 1800) {
			motor[swingingArm] = -60;
		}else if (SensorValue[armPot] > 1700) {
		motor[swingingArm] = -15;
		}else if (SensorValue[armPot] < 1500) {
		motor[swingingArm] = 120;
		} else if (SensorValue[armPot] < 1550) {
		motor[swingingArm] = 40;
		} else {
		motor[swingingArm] = 5;
	}
}

void rollerIntake(int speed) {
	motor[roller] = speed;
	rollerSpeed = speed;
	//	writeDebugStreamLine("Set speed %d", rollerSpeed);
}

void rollerOutake(int speed, int time) {
	if (time1[T3] < time) {
		motor[roller] = speed;
		} else {
		motor [roller] = 0;
		outakeFinished = true;
	}
}

//Drive function for auto
void drive(int left, int right) {
	turnMotor(driveFL, left);
	turnMotor(driveFR, right);
	turnMotor(driveBL, left);
	turnMotor(driveBR, right);
}
//Drive function with encoders for auto
void driveForward(int speed, int distance) {
	while (SensorValue[rightDriveEnc] < distance && SensorValue[leftDriveEnc] < distance) {
		writeDebugStreamLine(" Left Encoder: %d", SensorValue[leftDriveEnc]);
		writeDebugStreamLine(" Right Encoder: %d", SensorValue[rightDriveEnc]);
		writeDebugStreamLine("Moving forward");
		drive(speed, speed);
	}
	drive(0, 0);

	SensorValue[rightDriveEnc] = 0;
	SensorValue[leftDriveEnc] = 0;
	writeDebugStreamLine("Front Left Encoder: %d", SensorValue[leftDriveEnc]);
	writeDebugStreamLine("Front Right Encoder: %d", SensorValue[rightDriveEnc]);
}

void driveBackward(int speed, int distance) {
	while (SensorValue[rightDriveEnc] > distance && SensorValue[leftDriveEnc] > distance) {
		drive(speed, speed);
	}
	drive(0, 0);

	SensorValue[rightDriveEnc] = 0;
	SensorValue[leftDriveEnc] = 0;
}

void turnLeft(int speed, int distance) {
	while (SensorValue[leftDriveEnc] < distance && SensorValue[rightDriveEnc] > (-distance)) {
		drive(-speed, speed);
	}
	drive(0, 0);

	SensorValue[rightDriveEnc] = 0;
	SensorValue[leftDriveEnc] = 0;
}

void turnRight(int speed, int distance) {
	while (SensorValue[leftDriveEnc] > (-distance) && SensorValue[rightDriveEnc] < distance) {
		drive(speed, -speed);
	}
	drive(0, 0);

	SensorValue[rightDriveEnc] = 0;
	SensorValue[leftDriveEnc] = 0;
}

void clearDriveEnc() {
	SensorValue[rightDriveEnc] = 0;
	SensorValue[leftDriveEnc] = 0;
}

void moveLiftUp(int speed, int distance) {
	if (SensorValue[liftEnc] < distance) {
		motor [liftL] = speed;
		motor [liftR] = speed;
		} else {
		motor [liftL] = 0;
		motor [liftR] = 0;
	}
}

void moveLiftUpAuto(int speed, int distance) {
	while (SensorValue[liftEnc] < distance) {
		motor [liftL] = speed;
		motor [liftR] = speed;
	}
	motor [liftL] = 0;
	motor [liftR] = 0;
}

void moveLiftDown(int speed, int distance) {
	if (SensorValue[liftEnc] > distance) {
		motor [liftL] = -speed;
		motor [liftR] = -speed;
		} else {
		motor [liftL] = 0;
		motor [liftR] = 0;
	}
}

void autoLiftPIDControl (int position) {
	float liftCurrent;

	float liftProportion;

	float liftError;

	float encLift = SensorValue[liftEnc];

	//Find lift error
	liftError = position - encLift;

	liftProportion = liftError * autoLiftkp;

	liftCurrent = liftProportion;

	if (liftCurrent > 127) {
		liftCurrent = 127;
	}
	if (liftCurrent < -127) {
		liftCurrent = -127;
	}

	motor[liftL] = liftCurrent;
	motor[liftR] = liftCurrent;

	//writeDebugStreamLine("left pot %d", leftPot);
	//writeDebugStreamLine("             right pot %d", rightPot);
	//writeDebugStreamLine("arm %d", armIsReallyBack);
	//writeDebugStreamLine("  left integral %d", sharedIntegral);
	//writeDebugStreamLine("                          right integral %d", rightIntegral);
	//writeDebugStreamLine("position %d", position);
	//writeDebugStreamLine("          left error %d", liftLeftError);
	//writeDebugStreamLine("                  right error %d", liftRightError);
	//writeDebugStreamLine("                     left curent %d", leftCurrent);
	//writeDebugStreamLine("                                    right curent %d", rightCurrent);
	//writeDebugStreamLine("                               Change in position %d", (leftPot - leftLastPot));
	//writeDebugStreamLine("  liftLeftAtPosition %d", liftLeftAtPosition);
	//writeDebugStreamLine("  curent %d", leftCurrent);
	//writeDebugStreamLine("  derivative %f", leftDerivative);
	//writeDebugStreamLine("  integral %f", sharedIntegral);
	//writeDebugStreamLine("  proportion %f", leftProportion);

	datalogAddValueWithTimeStamp(0, time1(T4));
	//datalogAddValueWithTimeStamp(1, leftLastPot);
	//datalogAddValueWithTimeStamp(2, liftkd);
	//datalogAddValueWithTimeStamp(3, leftCurrent);
}

void liftPIDCalculate (int position) {
	float liftCurrent;

	float integralAcitveZone = 100;

	float liftProportion;
	float sharedIntegral;
	float liftDerivative;

	float liftError;
	float liftErrorT;
	float liftLastEnc;
	float encLastLift

	float encLift = SensorValue[liftEnc];

	//Find lift error
	liftError = position - encLift;

	liftProportion = liftError * liftkp;

	sharedIntegral = liftErrorT * liftki * 0.025;

	liftDerivative = ((encLift - encLastLift) * liftkd)/0.025;

	//Integral
	liftErrorT += liftError;
	if (sharedIntegral > 80) {
		sharedIntegral = 80;
		} else if (sharedIntegral < -80) {
		sharedIntegral = -80;
	}

	liftCurrent = liftProportion + sharedIntegral + liftDerivative;

	/*if (abs(leftPot - leftLastPot) <= 1) {
	liftLeftAtPosition = true;
	} else {
	liftLeftAtPosition = false;
	}
	if (abs(leftPot - leftLastPot) <= 1) {
	liftRightAtPosition = true;
	} else {
	liftRightAtPosition = false;
	}*/

	if (liftCurrent > 127) {
		liftCurrent = 127;
	}
	if (liftCurrent < -127) {
		liftCurrent = -127;
	}

	motor[liftL] = liftCurrent;
	motor[liftR] = liftCurrent;

	//writeDebugStreamLine("left pot %d", leftPot);
	//writeDebugStreamLine("             right pot %d", rightPot);
	//writeDebugStreamLine("arm %d", armIsReallyBack);
	//writeDebugStreamLine("  left integral %d", sharedIntegral);
	//writeDebugStreamLine("                          right integral %d", rightIntegral);
	//writeDebugStreamLine("position %d", position);
	//writeDebugStreamLine("          left error %d", liftLeftError);
	//writeDebugStreamLine("                  right error %d", liftRightError);
	//writeDebugStreamLine("                     left curent %d", leftCurrent);
	//writeDebugStreamLine("                                    right curent %d", rightCurrent);
	//writeDebugStreamLine("                               Change in position %d", (leftPot - leftLastPot));
	//writeDebugStreamLine("  liftLeftAtPosition %d", liftLeftAtPosition);
	//writeDebugStreamLine("  curent %d", leftCurrent);
	//writeDebugStreamLine("  derivative %f", leftDerivative);
	//writeDebugStreamLine("  integral %f", sharedIntegral);
	//writeDebugStreamLine("  proportion %f", leftProportion);

	datalogAddValueWithTimeStamp(0, time1(T4));
	//datalogAddValueWithTimeStamp(1, leftLastPot);
	//datalogAddValueWithTimeStamp(2, liftkd);
	//datalogAddValueWithTimeStamp(3, leftCurrent);

	encLastLift = encLift;

	clearTimer(T4);
}

void liftPIDControl (int position) {
	if (time1[T4] > 25) {
		liftPIDCalculate(position);
	}
}

void checkLiftPos (int height) {
	if (SensorValue[liftEnc] >= height - 500) {
		liftAtPosition = true;
		} else {
		liftAtPosition = false;
	}
}

void autoDrivePIDCalculate (int distance, bool time) {
	float encAverage = (SensorValue[leftDriveEnc]+SensorValue[rightDriveEnc])/2;

	//float integralAcitveZone = 100;

	float error;
	float proportion;
	float integral;
	float derivative;

	float errorT;
	float lastError;

	float current;

	//Find Distance error
	error = distance - encAverage;

	//Set proportion
	proportion = error * drivekp;

	integral = errorT * driveki * 0.025;

	derivative = ((error - lastError) * drivekd)/0.025;


	//Calculate integral
	//left
	errorT += error;
	if (integral > 80) {
		integral = 80;
		} else if (integral < -80) {
		integral = -80;
	}

	//Set current
	current = proportion + integral + derivative;
	driveCurrent = proportion + integral + derivative;

	/*if (abs(error) <= drivePositionError) {
	current = 0;
	}

	if (abs(error) <= driveTurnPositionError) {
	gyroCurrent = 0;
	}*/

	//Check that drive has stopped
	if (abs(error - lastError) <= 2) {
		driveAtPosition = true;
		} else {
		driveAtPosition = false;
	}

	if (current > 127) {
		current = 127;
	}
	if (current < -127) {
		current = -127;
	}


	motor[driveBL] = current;
	motor[driveFL] = current;
	motor[driveBR] = current;
	motor[driveFR] = current;

	//writeDebugStreamLine("Current Angle %d", encAverage);
	//writeDebugStreamLine("            error %d", error);
	//writeDebugStreamLine("            last error %d", lastError);
	//writeDebugStreamLine("        integral %d", integral);
	//writeDebugStreamLine("             error total %d", errorT);
	//writeDebugStreamLine("                      derivative %d", derivative);
	//writeDebugStreamLine("           last error %d", lastError);
	//writeDebugStreamLine("             drive current 2/ %d", current);
	//writeDebugStreamLine("proportion %d", proportion);
	//writeDebugStreamLine("             error %d", error);
	//writeDebugStreamLine("             distance %d", distance);

	//datalogAddValueWithTimeStamp(0, error);
	datalogAddValueWithTimeStamp(0, encAverage);
	/*datalogAddValueWithTimeStamp(2, integral);
	datalogAddValueWithTimeStamp(3, derivative);*/
	//datalogAddValueWithTimeStamp(3, lastError);
	datalogAddValueWithTimeStamp(2, current);
	datalogAddValueWithTimeStamp(1, distance);

	lastError = error;

	//Make sure the loop happens consistantly
	if (time) {
		clearTimer(T1);
	}
}

void autoDrivePIDControl(int distance, bool time) {
	if (time) {
		if (time1[T1] > 25) {
			autoDrivePIDCalculate(distance, time);
		}
		} else {
		autoDrivePIDCalculate(distance, time);
	}
}

void autoGyroPIDCalculate (int setAngle) {
	float angle = SensorValue(driveGyro);

	float integralAcitveZone = 1000;

	float proportion;
	float integral;
	float derivative;

	float errorT;
	float lastTurnError;

	float current;

	//Find Angle error
	turnError = setAngle - angle;

	//Set proportion
	proportion = turnError * turnkp;

	integral = errorT * turnki * 0.025;

	derivative = ((turnError - lastTurnError) * turnkd)/0.025;

	//Calculate integral
	errorT += turnError;
	if (integral > 80) {
		integral = 80;
		} else if (integral < -80) {
		integral = -80;
	}

	//Set current
	current = proportion + integral + derivative;

	/*if (abs(turnError) <= turnPositionError) {
	current = 0;
	}*/

	//Check that turn has stopped
	/*if (abs(turnError) <= turnPositionError) {
	turnAtPosition = true;
	} else {
	turnAtPosition = false;
	}*/

	if (current > 127) {
		current = 127;
	}
	if (current < -127) {
		current = -127;
	}

	//Send to motors
	motor[driveBL] = -current;
	motor[driveFL] = -current;
	motor[driveBR] = current;
	motor[driveFR] = current;

	//writeDebugStreamLine("Current Angle %d", currentAngle);
	//writeDebugStreamLine("            turn error %d", turnError);
	/*writeDebugStreamLine("             integral %d", integral);
	writeDebugStreamLine("             error total %d", errorT);
	writeDebugStreamLine("             derivative %d", derivative);
	writeDebugStreamLine("           last error %d", lastTurnError);*/
	//writeDebugStreamLine("             angle current 2/ %d", current);
	writeDebugStreamLine("gyro %d", angle);

	//datalogAddValueWithTimeStamp(4, turnError);
	datalogAddValueWithTimeStamp(0, angle);
	datalogAddValueWithTimeStamp(1, setAngle);
	datalogAddValueWithTimeStamp(2, current);
	/*datalogAddValueWithTimeStamp(2, integral);
	datalogAddValueWithTimeStamp(3, derivative);
	datalogAddValueWithTimeStamp(4, current);*/
	//datalogAddValueWithTimeStamp(4, turnError);

	lastTurnError = turnError;

	clearTimer(T1);
}

void autoGyroPIDControl (int setAngle) {
	if (time1[T1] > 25) {
		autoGyroPIDCalculate(setAngle);
	}
}

void autoDriveGyroPIDCalculate (int setAngle, int distance) {
	autoDrivePIDControl(distance, false);

	float angle = SensorValue(driveGyro);
	float gyroCurrent;

	//Find Angle error
	turnError = setAngle - angle;

	gyroCurrent = turnError * driveTurnkp;

	//Assign power to motors
	motor[driveBL] = driveCurrent - gyroCurrent;
	motor[driveFL] = driveCurrent - gyroCurrent;
	motor[driveBR] = driveCurrent + gyroCurrent;
	motor[driveFR] = driveCurrent + gyroCurrent;

	//Limit power to motors
	if (gyroCurrent > maxTurnPower) {
		gyroCurrent = maxTurnPower;
	}
	if (gyroCurrent < -maxTurnPower) {
		gyroCurrent = -maxTurnPower;
	}

	/*if (abs(turnError) <= turnDrivePositionError) {
	gyroCurrent = 0;
	}*/

	if (driveCurrent > 127 - maxTurnPower) {
		driveCurrent = (127 - maxTurnPower);
	}
	if (driveCurrent < -(127 - maxTurnPower)) {
		driveCurrent = -(127 - maxTurnPower);
	}

	/*writeDebugStreamLine("Angle current %d", gyroCurrent);
	writeDebugStreamLine("Drive current %d", driveCurrent);
	writeDebugStreamLine("             overall  current left %d", overallCurrentLeft);
	writeDebugStreamLine("             overall  current right %d", overallCurrentRight);*/
	//writeDebugStreamLine("             timer %d", SensorValue[driveGyro]);

	datalogAddValueWithTimeStamp(3, setAngle);
	datalogAddValueWithTimeStamp(4, angle);
	datalogAddValueWithTimeStamp(5, gyroCurrent);
	datalogAddValueWithTimeStamp(6, (driveCurrent + gyroCurrent));

	clearTimer(T1);
}

void autoDriveGyroPIDControl (int setAngle, int distance) {
	if (time1[T1] > 25) {
		autoDriveGyroPIDCalculate(setAngle, distance);
	}
}

void collectFirstBall() {
	if (allianceColor == BLUE_ALLIANCE){
	while (time1(T2) < 3952) {
		moveArmFlag();

		if (time1(T2) < 1450) {
			autoGyroPIDControl(-70);
		}

		if (time1(T2) > 1450 && time1(T2) < 3950) {
			autoDrivePIDControl(-1000, true);
			motor[roller] = -120;
		}
	}
} else if (allianceColor == RED_ALLIANCE){
	while (time1(T2) < 3952) {
		moveArmFlag();

		if (time1(T2) < 1450) {
			autoGyroPIDControl(60);
		}

		if (time1(T2) > 1450 && time1(T2) < 3950) {
			autoDrivePIDControl(-1000, true);
			motor[roller] = -120;
		}
	}
}
}

void allignWithFlags() {
	if (allianceColor == BLUE_ALLIANCE){
	while (time1(T2) < 3482) {
		moveArmFlag();
		motor[roller] = -127;

		if (time1(T2) < 600) {
			autoGyroPIDControl(50);
		}

		if (time1(T2) > 600 && time1(T2) < 2600) {
			autoDrivePIDControl(960, true);
			datalogAddValueWithTimeStamp(7, (SensorValue[leftDriveEnc]+SensorValue[rightDriveEnc])/2);
		}

		if (time1[T2] > 2600 && time1[T2] < 3450) {
			motor[roller] = 0;
			autoGyroPIDControl(830);
		} else if (time1[T2] > 3450 && time1[T2] < 3480) {
			motor[driveBL] = 0;
			motor[driveBR] = 0;
			motor[driveFL] = 0;
			motor[driveFR] = 0;
		}
	}
} else if (allianceColor == RED_ALLIANCE){
	while (time1(T2) < 2982) {
		moveArmFlag();
		motor[roller] = -127;

		if (time1(T2) < 600) {
			autoGyroPIDControl(-50);
		}

		if (time1(T2) > 600 && time1(T2) < 2000) {
			autoDrivePIDControl(1080, true);
			datalogAddValueWithTimeStamp(7, (SensorValue[leftDriveEnc]+SensorValue[rightDriveEnc])/2);
		}

		if (time1[T2] > 2000 && time1[T2] < 2950) {
			motor[roller] = 0;
			autoGyroPIDControl(-1060);
		} else if (time1[T2] > 2950 && time1[T2] < 2980) {
			motor[driveBL] = 0;
			motor[driveBR] = 0;
			motor[driveFL] = 0;
			motor[driveFR] = 0;
		}
	}
}
}

void scoreHighFlag() {
	if (allianceColor == BLUE_ALLIANCE){
	while (time1(T2) < 2904) {
		moveArmFlag();
		motor[roller] = 0;

		if (time1(T2) < 2903) {
			autoDrivePIDControl(360, true);
		}

		if (time1(T2) > 850 && time1(T2) < 2850) {
			motor[shooter] = -127;
		}

		if (time1(T2) > 2850 && time1(T2) < 2900) {
			motor[shooter] = 0;
		}
	}
} else if (allianceColor == RED_ALLIANCE){
	while (time1(T2) < 2714) {
		moveArmFlag();
		if (time1[T2] > 1000) {
			motor[roller] = 0;
		}

		if (time1[T2] > 1) {
			autoDrivePIDControl(440, true);
		}

		if (time1(T2) > 1100 && time1(T2) < 2700) {
			motor[shooter] = -127;
		}

		if (time1(T2) > 2700 && time1(T2) < 2710) {
			motor[shooter] = 0;
		}
	}
}
}

void scoreBottomTwoFlags() {
	if (allianceColor == BLUE_ALLIANCE){
	while (time1(T2) < 5010) {
		moveArmFlag();

		if (time1(T2) < 550) {
			autoGyroPIDControl(930);
		}

		if (time1(T2) > 550 && time1(T2) < 2400) {
			autoDrivePIDControl(630, true);
			motor[roller] = -127;
		}

		if (time1(T2) > 2400 && time1(T2) < 3400) {
			autoGyroPIDControl(860);
		}

		if (time1(T2) > 3100 && time1(T2) < 5000) {
			motor[shooter] = -127;
		}

		if (time1(T2) > 5000 && time1(T2) < 5002) {
			motor[shooter] = 0;
		}
	}
} else if (allianceColor == RED_ALLIANCE){
	while (time1(T2) < 5010) {
		if (time1(T2) < 1500) {
			moveArmFlag();
		}
		motor[roller] = -127;

		if (time1(T2) < 650) {
			autoGyroPIDControl(-900);
		}

		if (time1(T2) > 650 && time1(T2) < 1800) {
			autoDrivePIDControl(650, true);
		}

		if (time1(T2) > 1800 && time1(T2) < 2600) {
			moveArmOut();
			autoDrivePIDControl(460, true);
		}

		if (time1(T2) > 2600 && time1[T2] < 3200) {
			moveArmOut();
			autoGyroPIDControl(-1255);
		}

		if (time1(T2) > 3200 && time1[T2] < 3210) {
			moveArmOut();
			clearDriveEnc();
		}

		if (time1(T2) > 3210) {
			moveArmOut();
			autoDrivePIDControl(100, true);
		}

		if (time1(T2) > 3100 && time1(T2) < 5000) {
			motor[shooter] = -127;
		}

		if (time1(T2) > 5000 && time1(T2) < 5002) {
			motor[shooter] = 0;
		}
	}
}
}

void skillsStuff() {
	if (allianceColor == BLUE_ALLIANCE) {
		while (time1[T2] < 10000) {
			if (time1[T2] < 1000) {
				autoGyroPIDControl(900);
			}

			if (time1[T2] > 1000 && time1[T2] < 4000) {
				autoDrivePIDControl(-1700, true);
			}

			if (time1[T2] > 4000 && time1[T2] < 6000) {
				autoGyroPIDControl(0);
			}

			if (time1[T2] > 6000 && time1[T2] < 6050) {
				clearDriveEnc();
			}

			if (time1[T2] > 6050) {
				autoDrivePIDControl(-900, true);
			}

		}
	} else if (allianceColor == RED_ALLIANCE) {
			while (time1[T2] < 10000) {
			if (time1[T2] < 1000) {
				autoGyroPIDControl(-900);
			}

			if (time1[T2] > 1000 && time1[T2] < 4000) {
				autoDrivePIDControl(-1500, true);
			}

			if (time1[T2] > 4000 && time1[T2] < 6000) {
				autoGyroPIDControl(0);
			}

			if (time1[T2] > 6000 && time1[T2] < 6050) {
				clearDriveEnc();
			}

			if (time1[T2] > 6050) {
				autoDrivePIDControl(-900, true);
			}

			}
		}
	}
